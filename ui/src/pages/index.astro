---
// Main dashboard page
import Header from "../components/Header.astro";
import SlavesPanel from "../components/SlavesPanel.astro";
import ConfigPanel from "../components/ConfigPanel.astro";
import ControlPanel from "../components/ControlPanel.astro";
import TelemetryPanel from "../components/TelemetryPanel.astro";
import PreviewPanel from "../components/PreviewPanel.astro";
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content={Astro.generator} />
    <title>WPlace Master Dashboard</title>
    <style>
      :root {
        --background: 0 0% 100%;
        --foreground: 222.2 84% 4.9%;
        --card: 0 0% 100%;
        --card-foreground: 222.2 84% 4.9%;
        --popover: 0 0% 100%;
        --popover-foreground: 222.2 84% 4.9%;
        --primary: 222.2 47.4% 11.2%;
        --primary-foreground: 210 40% 98%;
        --secondary: 210 40% 96%;
        --secondary-foreground: 222.2 84% 4.9%;
        --muted: 210 40% 96%;
        --muted-foreground: 215.4 16.3% 46.9%;
        --accent: 210 40% 96%;
        --accent-foreground: 222.2 84% 4.9%;
        --destructive: 0 84.2% 60.2%;
        --destructive-foreground: 210 40% 98%;
        --border: 214.3 31.8% 91.4%;
        --input: 214.3 31.8% 91.4%;
        --ring: 222.2 84% 4.9%;
        --radius: 0.5rem;
      }
      
      .dark {
        --background: 222.2 84% 4.9%;
        --foreground: 210 40% 98%;
        --card: 222.2 84% 4.9%;
        --card-foreground: 210 40% 98%;
        --popover: 222.2 84% 4.9%;
        --popover-foreground: 210 40% 98%;
        --primary: 210 40% 98%;
        --primary-foreground: 222.2 47.4% 11.2%;
        --secondary: 217.2 32.6% 17.5%;
        --secondary-foreground: 210 40% 98%;
        --muted: 217.2 32.6% 17.5%;
        --muted-foreground: 215 20.2% 65.1%;
        --accent: 217.2 32.6% 17.5%;
        --accent-foreground: 210 40% 98%;
        --destructive: 0 62.8% 30.6%;
        --destructive-foreground: 210 40% 98%;
        --border: 217.2 32.6% 17.5%;
        --input: 217.2 32.6% 17.5%;
        --ring: 212.7 26.8% 83.9%;
      }
    </style>
    <!-- Make flash animations global so they apply to dynamically-generated slave cards -->
    <style is:global>
      @keyframes card-flash-green {
        0% { box-shadow: 0 0 0 0 rgba(16,185,129,0.0), 0 0 0 0 rgba(16,185,129,0.0) inset; }
        20% { box-shadow: 0 0 0 3px rgba(16,185,129,0.9), 0 0 18px 2px rgba(16,185,129,0.6) inset; }
        80% { box-shadow: 0 0 0 3px rgba(16,185,129,0.6), 0 0 12px 1px rgba(16,185,129,0.35) inset; }
        100% { box-shadow: 0 0 0 0 rgba(16,185,129,0.0), 0 0 0 0 rgba(16,185,129,0.0) inset; }
      }
      @keyframes card-flash-red {
        0% { box-shadow: 0 0 0 0 rgba(239,68,68,0.0), 0 0 0 0 rgba(239,68,68,0.0) inset; }
        20% { box-shadow: 0 0 0 3px rgba(239,68,68,0.9), 0 0 18px 2px rgba(239,68,68,0.6) inset; }
        80% { box-shadow: 0 0 0 3px rgba(239,68,68,0.6), 0 0 12px 1px rgba(239,68,68,0.35) inset; }
        100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.0), 0 0 0 0 rgba(239,68,68,0.0) inset; }
      }
      .flash-green { animation: card-flash-green 1.2s ease-out; }
      .flash-red { animation: card-flash-red 1.2s ease-out; }
      
      /* Animaci√≥n suave del spinner para el bot√≥n Start */
      @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
      
      .animate-spin {
        animation: spin 1s linear infinite;
      }
      
      /* Transiciones suaves para el bot√≥n Start */
      #start-btn-text,
      #start-btn-spinner {
        transition: opacity 300ms cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      /* Asegurar que el spinner tenga el tama√±o correcto */
      #start-btn-spinner .animate-spin {
        animation: spin 0.8s linear infinite;
      }
    </style>
  </head>
  <body class="min-h-screen bg-background font-sans antialiased">
    <div id="app">
      <!-- Header -->
      <Header />

      <!-- Main Content -->
      <main class="container mx-auto px-4 py-8">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <!-- Left column: Slaves + Config stacked -->
          <div class="space-y-6 lg:col-span-1">
            <SlavesPanel />
            <ConfigPanel />
          </div>

          <!-- Right side: Control, Telemetry, Preview -->
          <div class="lg:col-span-2">
            <ControlPanel />
            <TelemetryPanel />
            <PreviewPanel />
            <!-- (Logs moved under Connected Slaves) -->
          </div>
        </div>
      </main>
    </div>

    <!-- Dashboard JavaScript -->
    <script>
      class WPlaceDashboard {
        ws: WebSocket | null;
        slaves: Map<string, any>;
        currentSession: any;
        chargeUpdateInterval: any;
        chargeCountdown: number;
        currentProject: any;
        activeProject: any; // alias legacy para limpieza
        previewZoom: number;
        detectedBotMode: string | null;
        projectConfig: any;
        guardConfig: any;
        autoDistribute: boolean;
        lastPreviewData: any; // added
  guardPreview: any; // added preview state
        previewChanges: any[]; // listado filtrado actual
        previewMeta: any; // metadatos adicionales
        lastPreviewAt: number; // throttle preview
        recentLogKeys: Map<string, number>; // dedupe keys with TTL
  currentRoundPlan: Record<string, number>;
  _previewRefreshCooldownUntil: number;
  _selectedSlavesLocal: Set<string>;
  _selectedSlavesServer: Set<string>;
  _preferredColorIds: Set<number>;
  _excludedColorIds: Set<number>;
  _configWired: boolean;
  _saveTimer: any;
  sessionStatus: 'running' | 'paused' | null;
  _recentRepairs: Map<string, number>; // TTL por previews para no repintar
  _recentTTL: number;
  _flashTimers: Map<string, any>;
        constructor() {
          this.ws = null;
          this.slaves = new Map();
    this.currentSession = null; // Initialize current session
          this.chargeUpdateInterval = null;
          this.chargeCountdown = 30;
          this.currentProject = null;
          this.activeProject = null;
          this.previewZoom = 1;
          this.detectedBotMode = null;
          this.projectConfig = null;
          this.guardConfig = {};
          this.autoDistribute = false;
          // Estrategia de distribuci√≥n de cargas (frontend mirror del backend)
          this.guardConfig.chargeStrategy = this.guardConfig.chargeStrategy || 'greedy';
          this.lastPreviewData = null; // init
          this.guardPreview = { analysis:null, togglesInitialized:false, show:{correct:true, incorrect:true, missing:true}, area:null };
          this.previewChanges = [];
          this.previewMeta = {};
          this.lastPreviewAt = 0;
          this.recentLogKeys = new Map();
          this.currentRoundPlan = {};
          this._previewRefreshCooldownUntil = 0;
          this.init();
          // Cargar selecci√≥n local inicial
          try {
            const saved = JSON.parse(localStorage.getItem('selectedSlaves') || '[]');
            this._selectedSlavesLocal = new Set(Array.isArray(saved) ? saved : []);
          } catch { this._selectedSlavesLocal = new Set(); }
          this._preferredColorIds = new Set();
          this._excludedColorIds = new Set();
          this._configWired = false;
          this._saveTimer = null;
          this.sessionStatus = null;
          this._recentRepairs = new Map();
          this._recentTTL = 5; // considerar reparado durante 5 previews del favorito
          this._flashTimers = new Map();
        }

        init() {
          this.connectWebSocket();
          this.setupEventListeners();
          this.setupPreviewListeners();
          this.startChargeUpdateSystem();
    this.loadGuardConfig(); // Load guard configuration
      this.setupConfigPanelListeners();
          this.restorePreviewPreferredHeight();
          // Estado inicial de controles: sin slaves => deshabilitar botones dependientes
          try { this.updateControlButtons(); } catch {}
      try { this.updateConfigPanelEnabledState(); } catch {}
        }

        renderPreview(){
          // M√©todo m√≠nimo: si no hay datos limpiar canvas y stats
          try {
            const canvas = document.getElementById('preview-canvas') as HTMLCanvasElement | null;
            const ctx = canvas?.getContext('2d');
            if (!canvas || !ctx){ return; }
            if(!this.lastPreviewData){
              ctx.clearRect(0,0,canvas.width,canvas.height);
              const stats = document.getElementById('guard-preview-stats');
              if(stats) stats.textContent = 'Sin datos';
              return;
            }
            // Si existe una imagen previa mantener (renderizado detallado est√° en otra parte del c√≥digo que no tocamos).
          } catch {}
        }

  // Stubs (ya exist√≠an en versi√≥n previa del archivo, se redefinen si faltan)
  setupPreviewListeners(){ /* placeholder legacy; mantiene zoom botones */ }
  startChargeUpdateSystem(){ /* placeholder auto update charges si backend provee */ }

        // Funciones de zoom para el preview (escalado por width/height, no por transform)
        getMaxAllowedZoom() {
          const canvas = document.getElementById('preview-canvas') as HTMLCanvasElement | null;
          const container = document.getElementById('canvas-container') as HTMLElement | null;
          if (!canvas || !container || !canvas.width || !canvas.height) return 1;
          const cs = getComputedStyle(container);
          const padX = parseFloat(cs.paddingLeft || '0') + parseFloat(cs.paddingRight || '0');
          const padY = parseFloat(cs.paddingTop || '0') + parseFloat(cs.paddingBottom || '0');
          const innerW = Math.max(0, container.clientWidth - padX);
          const innerH = Math.max(0, container.clientHeight - padY);
          const stats = document.getElementById('guard-preview-stats') as HTMLElement | null;
          const statsH = stats ? stats.offsetHeight + 8 : 0;
          const SAFE = 0.99;
          const scaleX = innerW / canvas.width;
          const scaleY = Math.max(0.1, (innerH - statsH) / canvas.height);
          const cap = Math.max(0.1, Math.min(scaleX, scaleY)) * SAFE;
          return isFinite(cap) && cap > 0 ? cap : 1;
        }

        setZoom(zoom) {
          const canvas = document.getElementById('preview-canvas') as HTMLCanvasElement;
          if (!canvas || !canvas.width || !canvas.height) return;
          const maxAllowed = this.getMaxAllowedZoom();
          const minAllowed = 0.5; // consistente con el slider
          const clamped = Math.max(minAllowed, Math.min(zoom, maxAllowed));
          this.previewZoom = clamped;
          // Escalado real para que el layout conozca el tama√±o y no recorte
          canvas.style.width = `${Math.max(1, Math.round(canvas.width * clamped))}px`;
          canvas.style.height = `${Math.max(1, Math.round(canvas.height * clamped))}px`;
          // Sincronizar UI (slider y etiqueta)
          const zoomSlider = document.getElementById('zoom-slider') as HTMLInputElement | null;
          const zoomLevel = document.getElementById('zoom-level') as HTMLElement | null;
          if (zoomSlider) zoomSlider.value = String(clamped);
          if (zoomLevel) zoomLevel.textContent = `${Math.round(clamped * 100)}%`;
        }

  fitZoom() {
          const canvas = document.getElementById('preview-canvas') as HTMLCanvasElement;
          const container = document.getElementById('canvas-container');
          if (!canvas || !container) return;

          // Medidas internas √∫tiles (restar paddings)
          const cs = getComputedStyle(container);
          const padX = parseFloat(cs.paddingLeft || '0') + parseFloat(cs.paddingRight || '0');
          const padY = parseFloat(cs.paddingTop || '0') + parseFloat(cs.paddingBottom || '0');
          const innerW = Math.max(0, container.clientWidth - padX);
          const innerH = Math.max(0, container.clientHeight - padY);

          // Reservar espacio para el bloque de estad√≠sticas (si existe)
          const stats = document.getElementById('guard-preview-stats');
    const statsH = stats ? (stats as HTMLElement).offsetHeight + 8 : 0; // usar alto intr√≠nseco del canvas

          const scaleX = innerW / canvas.width;
          const scaleY = Math.max(0.1, (innerH - statsH) / canvas.height);
          // Permitir escalar por encima de 1 hasta 5x
          // Margen de seguridad para evitar recortes por redondeos/bordes
          const SAFE = 0.99;
          const scale = Math.max(0.1, Math.min(scaleX, scaleY, 5)) * SAFE;

          this.setZoom(scale);

          // UI
          const zoomSlider = document.getElementById('zoom-slider') as HTMLInputElement;
          const zoomLevel = document.getElementById('zoom-level');
          if (zoomSlider) zoomSlider.value = scale.toString();
          if (zoomLevel) zoomLevel.textContent = `${Math.round(scale * 100)}%`;
        }

        adjustPreviewSize() {
          const canvas = document.getElementById('preview-canvas') as HTMLCanvasElement | null;
          const previewContent = document.getElementById('preview-content');
          const panel = document.getElementById('preview-panel');
          const container = document.getElementById('canvas-container');
          if (!previewContent || !panel || panel.style.display === 'none') return;

          // L√≠mites seguros y c√°lculo de disponible
          const MIN_H = 520;
          const MAX_VH = 0.92; // usar m√°s alto de la ventana
          const B_MARGIN = 2; // minimizar margen inferior extra

          const rect = previewContent.getBoundingClientRect();
          const viewportCap = Math.floor(window.innerHeight * MAX_VH);
          const availByViewport = Math.max(0, Math.floor(window.innerHeight - rect.top - B_MARGIN));

          // Si el usuario ha elegido una altura preferida, respetarla (clamp a l√≠mites)
          let savedH = 0;
          try { savedH = parseInt(localStorage.getItem('previewPanel.height') || '0', 10) || 0; } catch {}
          if (savedH > 0) {
            const clamped = Math.max(MIN_H, Math.min(savedH, viewportCap, availByViewport));
            previewContent.style.height = `${clamped}px`;
            if (canvas && canvas.width > 0 && canvas.height > 0) setTimeout(() => this.fitZoom(), 0);
            this.log(`üìè Preview height (user) ${clamped}px`);
            return;
          }

          // Altura necesaria exacta seg√∫n contenido visible
          const stats = document.getElementById('guard-preview-stats');
          const statsH = stats ? (stats as HTMLElement).offsetHeight : 0; // ya incluye paddings
          const padY = container ? (() => { const cs = getComputedStyle(container); return (parseFloat(cs.paddingTop||'0') + parseFloat(cs.paddingBottom||'0')); })() : 0;
          const canvasH = canvas ? canvas.offsetHeight : 0; // escalado efectivo
          const needed = Math.ceil(canvasH + statsH + padY);

          const finalH = Math.max(MIN_H, Math.min(needed, viewportCap, availByViewport));
          previewContent.style.height = `${finalH}px`;

          // Reajustar zoom a la nueva altura disponible
          if (canvas && canvas.width > 0 && canvas.height > 0) setTimeout(() => this.fitZoom(), 0);

          this.log(`üìè Preview height set to ${finalH}px (needed=${needed}, cap=${viewportCap}, avail=${availByViewport})`);
        }

        connectWebSocket() {
          const wsUrl = this.getWebSocketUrl();
          
          this.log(`üîå Connecting to WebSocket: ${wsUrl}`);
          this.ws = new WebSocket(wsUrl);
          
          this.ws.onopen = () => {
            this.log('‚úÖ Connected to Master server via WebSocket');
            // Solicitar un refresh de preview tras conectar
            try { setTimeout(() => this.requestPreviewRefreshThrottle(), 250); } catch {}
          };
          
          this.ws.onmessage = (event) => {
            try {
                  const raw = JSON.parse(event.data);
                  const unwrapResult = this._maybeUnwrapCompressed(raw);
                  const processMessages = (val) => {
                    if (!val) return;
                    const list = Array.isArray(val) ? val : [val];
                    for (const m of list) {
                      if (!m) continue;
                      this.logOnce(`ws:${m.type}`, `üì® Received WebSocket message: ${m.type}`, 1200);
                      this.handleWebSocketMessage(m);
                    }
                  };
                  if (unwrapResult && typeof unwrapResult.then === 'function') {
                    unwrapResult.then(processed => processMessages(processed));
                  } else {
                    processMessages(unwrapResult);
                  }
            } catch (error) {
              this.log(`‚ùå Error parsing WebSocket message: ${error.message}`);
            }
          };
          
          this.ws.onclose = (event) => {
            this.log(`üîå WebSocket disconnected (code: ${event.code}, reason: ${event.reason || 'Unknown'})`);
            this.log('üîÑ Attempting to reconnect in 3 seconds...');
            setTimeout(() => this.connectWebSocket(), 3000);
          };
          
          this.ws.onerror = (error) => {
            this.log(`‚ùå WebSocket error: ${error}`);
          };
        }

        handleWebSocketMessage(message) {
          this.logOnce(`proc:${message.type}`, `üîÑ Processing message type: ${message.type}`, 1200);
          
          switch (message.type) {
            case 'projects_cleared':
              this.log('üßπ Proyecto(s) limpiado(s)');
              try {
                const statusEl = document.getElementById('file-status'); if (statusEl) statusEl.textContent = 'No file selected';
                this.activeProject = null; this.projectConfig = null; this.detectedBotMode = null;
                this.lastPreviewData = null; this.previewChanges = []; this.previewMeta = {};
                this.guardPreview = { analysis:null, togglesInitialized:false, show:{correct:true, incorrect:true, missing:true}, area:null };
                const panel = document.getElementById('preview-panel') as HTMLElement | null; if (panel) panel.style.display = 'none';
                ['repaired-pixels','incorrect-pixels','missing-pixels'].forEach(id=>{ const el=document.getElementById(id); if(el) el.textContent='0'; });
                try { localStorage.removeItem('previewPanel.height'); } catch {}
                this.updateControlButtons();
              } catch{}
              this.renderPreview();
              break;
            case 'initial_state':
              this.log(`üìã Initial state received with ${(message.slaves || []).length} slaves`);
              this.updateSlavesList(message.slaves || []);
              try {
                if (Array.isArray(message.selected_slaves)) {
                  this._selectedSlavesServer = new Set(message.selected_slaves);
                }
                // Rehidratar paleta de colores si el backend la env√≠a
                if (Array.isArray(message.available_colors) && message.available_colors.length > 0) {
                  if (!this.lastPreviewData) this.lastPreviewData = {} as any;
                  const hasPalette = Array.isArray((this.lastPreviewData as any).availableColors) && (this.lastPreviewData as any).availableColors.length > 0;
                  if (!hasPalette) {
                    (this.lastPreviewData as any).availableColors = message.available_colors;
                    this.log('üé® Paleta cargada desde initial_state');
                    try { this.renderAllInlineChips(); } catch {}
                  }
                }
                const fav = (message.slaves || []).find(s => s.is_favorite && s.telemetry && s.telemetry.preview_data);
                if (fav) {
                  this.log(`üîÅ Loading persisted preview from favorite slave ${fav.id}`);
                  // Inferir modo a partir del preview
                  try {
                    const pd = fav.telemetry.preview_data;
                    const looksGuard = !!(pd && (pd.protectedArea || pd.area || pd.correctPixelsList || pd.incorrectPixelsList || pd.missingPixelsList || pd.analysis));
                    const looksImage = !!(pd && (pd.imageData && (pd.imageData.fullPixelData || (pd.imageData.width && pd.imageData.height))));
                    if (looksGuard) this.detectedBotMode = 'Guard';
                    else if (looksImage) this.detectedBotMode = 'Image';
                    const detectedEl = document.getElementById('detected-mode'); if (detectedEl) detectedEl.textContent = this.detectedBotMode ? `Detected mode: ${this.detectedBotMode}` : 'No file loaded - mode will be auto-detected';
                  } catch {}
                  this.updatePreviewFromSlave(fav.id, fav.telemetry.preview_data);
                  // Render directo en caso de saltar alguna ruta
                  this.renderGuardPreviewCanvas(fav.telemetry.preview_data);
                  try { this.updateControlButtons(); } catch {}
                }
                // Rehidratar sesi√≥n/proyecto si existen en servidor
                const sessions = Array.isArray(message.sessions) ? message.sessions : [];
                const projects = Array.isArray(message.projects) ? message.projects : [];
                // Elegir sesi√≥n activa: preferir 'running', si no, 'paused'
                const running = sessions.find(s => s.status === 'running');
                const paused = sessions.find(s => s.status === 'paused');
                const sess = running || paused || sessions[0];
                if (sess) {
                  this.currentSession = sess.id || sess.session_id || null;
                  this.sessionStatus = (sess.status as any) || null;
                  this.log(`‚ôªÔ∏è Rehydrated session: ${this.currentSession} (status=${sess.status||'unknown'})`);
                  // Preseleccionar slaves de la sesi√≥n
                  if (Array.isArray(sess.slave_ids)) {
                    setTimeout(() => {
                      try {
                        const ids = new Set(sess.slave_ids);
                        document.querySelectorAll<HTMLInputElement>('.slave-toggle').forEach(cb => { cb.checked = ids.has(cb.value); this.updateToggleState(cb.id, cb.checked); });
                        this.updateControlButtons();
                      } catch {}
                    }, 50);
                  }
                  // Cargar proyecto asociado
                  const proj = projects.find(p => (p.id === sess.project_id));
                  if (proj) {
                    // Normalizar modo
                    const m = (proj.mode || '').toString().toLowerCase();
                    this.detectedBotMode = m.startsWith('guard') ? 'Guard' : (m.startsWith('image') ? 'Image' : (proj.mode || null));
                    this.projectConfig = proj.config || null;
                    const detectedEl = document.getElementById('detected-mode'); if (detectedEl) detectedEl.textContent = this.detectedBotMode ? `Detected mode: ${this.detectedBotMode}` : 'No file loaded - mode will be auto-detected';
                    const statusEl = document.getElementById('file-status'); if (statusEl) statusEl.textContent = proj.name ? `Loaded from server: ${proj.name}` : 'Loaded from server';
                    // Mostrar preview panel si hay datos
                    const panel=document.getElementById('preview-panel'); if(panel){ panel.style.display='block'; }
                    // Si es Guard y a√∫n no hay preview en memoria, solicitarlo
                    try {
                      if ((this.detectedBotMode||'').toLowerCase().startsWith('guard') && !this.lastPreviewData) {
                        this.requestPreviewRefreshThrottle();
                      }
                    } catch {}
                  }
                  // Botones seg√∫n estado
                  const startBtn = document.getElementById('start-btn') as HTMLButtonElement | null;
                  const pauseBtn = document.getElementById('pause-btn') as HTMLButtonElement | null;
                  const stopBtn = document.getElementById('stop-btn') as HTMLButtonElement | null;
                  const oneBatchBtn = document.getElementById('one-batch-btn') as HTMLButtonElement | null;
                  if (sess.status === 'running') {
                    if (startBtn) startBtn.disabled = true;
                    if (pauseBtn) pauseBtn.disabled = false;
                    if (stopBtn) stopBtn.disabled = false;
                    if (oneBatchBtn) oneBatchBtn.disabled = false;
                  } else if (sess.status === 'paused') {
                    if (startBtn) startBtn.disabled = false;
                    if (pauseBtn) pauseBtn.disabled = true;
                    if (stopBtn) stopBtn.disabled = false;
                    if (oneBatchBtn) oneBatchBtn.disabled = false;
                  }
                  // Re-evaluar con reglas de gating actuales
                  try { this.updateControlButtons(); } catch {}
                }
              } catch (e) { this.log('Error loading persisted preview: '+ e.message); }
              // Si no hay favorito y estamos en Guard con slaves ‚Üí autoasignar primero como favorito
              try {
                const anyFav = Array.from(this.slaves.values()).some((s:any) => s && s.is_favorite);
                if (!anyFav && this.detectedBotMode && this.detectedBotMode.toLowerCase().startsWith('guard') && this.slaves.size > 0) {
                  const first = Array.from(this.slaves.values())[0];
                  if (first && first.id) {
                    this.log(`‚≠ê No hab√≠a favorito; autoasignando ${first.id}`);
                    this.setFavoriteSlave(first.id).then(()=>{ try { this.requestPreviewRefreshThrottle(); } catch {} }).catch(()=>{});
                  }
                }
              } catch {}
              // Pedir refresh para reanudar flujo de preview tras recarga
              try { this.requestPreviewRefreshThrottle(); } catch {}
              break;
            case 'slave_connected':
              this.log(`ü§ñ Slave connected: ${message.slave_id}`);
              // Agregar un peque√±o delay para asegurar que el servidor ha actualizado su estado
              setTimeout(() => {
                this.refreshSlaves();
              }, 100);
              break;
            case 'slave_reconnected':
              this.log(`üîÑ Slave reconnected: ${message.slave_id}`);
              // Agregar un peque√±o delay para asegurar que el servidor ha actualizado su estado
              setTimeout(() => {
                this.refreshSlaves();
              }, 100);
              break;
            case 'slave_disconnected':
              this.log(`üîå Slave disconnected: ${message.slave_id}`);
              this.slaves.delete(message.slave_id);
              this.displaySlaves();
              break;
            case 'ui_selected_slaves':
              if (Array.isArray(message.slave_ids)) {
                this._selectedSlavesServer = new Set(message.slave_ids);
                if (this.slaves.size > 0) {
                  // Si ya tenemos slaves renderizados, aplicamos directamente
                  this.applyServerSelection();
                } else {
                  // Si a√∫n no est√°n, se aplicar√° tras el primer displaySlaves()
                  this.displaySlaves();
                }
              }
              break;
            case 'telemetry_update':
              this.log(`üìà Telemetry from ${message.slave_id}: charges=${message.telemetry?.remaining_charges || 'N/A'}`);
              this.updateTelemetry(message.slave_id, message.telemetry);
              try {
                if (message.telemetry && message.telemetry.preview_data) {
                  // Si viene preview del favorito, envejecer bloqueos
                  try { const favId = this.getFavoriteSlaveId(); if (favId && favId === message.slave_id) this.ageRecentRepairs(); } catch {}
                  // Renderizar preview si llega embebido en telemetr√≠a
                  const pd = message.telemetry.preview_data;
                  // Fijar modo si a√∫n no est√°
                  if (!this.detectedBotMode) {
                    const looksGuard = !!(pd && (pd.protectedArea || pd.area || pd.correctPixelsList || pd.incorrectPixelsList || pd.missingPixelsList || pd.analysis));
                    const looksImage = !!(pd && (pd.imageData && (pd.imageData.fullPixelData || (pd.imageData.width && pd.imageData.height))));
                    if (looksGuard) this.detectedBotMode = 'Guard'; else if (looksImage) this.detectedBotMode = 'Image';
                    const detectedEl = document.getElementById('detected-mode'); if (detectedEl) detectedEl.textContent = this.detectedBotMode ? `Detected mode: ${this.detectedBotMode}` : 'No file loaded - mode will be auto-detected';
                  }
                  this.updatePreviewFromSlave(message.slave_id, pd);
                  this.recomputeRoundPlan();
                  this.updateControlButtons();
                }
              } catch {}
              break;
            case 'status_update':
              this.log(`üìä Status update from ${message.slave_id}: ${message.status}`);
              this.updateSlaveStatus(message.slave_id, message.status);
              break;
            case 'log':
              this.log(`[${message.slave_id}] ${message.message}`);
              break;
            // NUEVO: evento de favorito desde el servidor para actualizar UI sin recargar
            case 'slave_favorite':
              this.log(`‚≠ê Slave ${message.slave_id} marked as favorite`);
              this.slaves.forEach(s => { if (s) s.is_favorite = false; });
              if (this.slaves.has(message.slave_id)) {
                this.slaves.get(message.slave_id).is_favorite = true;
              }
              this.displaySlaves();
              break;
            // NUEVO: datos de preview del Fav-Slave
            case 'preview_data':
              {
                const now = Date.now();
                if (now - this.lastPreviewAt < 5000) {
                  // Throttle preview updates to every 5s
                  this.logOnce('throttle:preview', '‚è±Ô∏è Preview update throttled', 3000);
                  break;
                }
                this.lastPreviewAt = now;
                this.log(`üñºÔ∏è Preview data from ${message.slave_id}: ${message.data ? 'Data received' : 'No data'}`);
                if (message.data && message.data.analysis) {
                  this.logOnce('preview:summary', `üìä Preview analysis: ${message.data.analysis.correctPixels || 0} correct, ${message.data.analysis.incorrectPixels || 0} incorrect, ${message.data.analysis.missingPixels || 0} missing`, 3000);
                }
                // Envejecer bloqueos s√≥lo si el preview viene del favorito
                try { const favId = this.getFavoriteSlaveId(); if (favId && favId === message.slave_id) this.ageRecentRepairs(); } catch {}
                this.updatePreviewFromSlave(message.slave_id, message.data);
                this.recomputeRoundPlan();
                try { this.updateControlButtons(); } catch {}
              }
              break;
            
            case 'repair_ack':
              this.logOnce(`ack:${message.slave_id}:${message.total_repairs}`, `üîß Slave ${message.slave_id} acknowledged repair order: ${message.total_repairs} pixels`, 5000);
              break;
            
            case 'repair_progress':
              this.logOnce(`prog:${message.slave_id}:${message.completed}/${message.total}`, `üé® Slave ${message.slave_id} repair progress: ${message.completed}/${message.total} pixels`, 3500);
              break;
            
            case 'repair_complete':
              this.logOnce(`done:${message.slave_id}:${message.completed}`, `‚úÖ Slave ${message.slave_id} completed repairs: ${message.completed} pixels`, 8000);
              try {
                // Resaltar en verde al completar lote
                this.highlightSlaveCard(String(message.slave_id), true);
              } catch {}
              this.requestPreviewRefreshThrottle();
              break;
            
            // NUEVO: eventos de pintado granular desde el slave
            case 'paint_progress':
              this.logOnce(`paint:prog:${message.slave_id}:${message.tileX},${message.tileY}:${message.completed}/${message.total}`,
                `üéØ Paint progress ${message.completed}/${message.total} en tile ${message.tileX},${message.tileY} [${message.slave_id}]`, 3000);
              break;
            case 'paint_result':
              {
                const ok = message.ok ?? message.success ?? (message.status === 'ok');
                const msg = ok ? `‚úÖ Pintado correcto (${message.painted || message.completed || 0})` : `‚ùå Pintado fallido: ${message.error || message.status || 'unknown'}`;
                this.logOnce(`paint:res:${message.slave_id}:${ok}:${message.painted||message.completed||0}:${message.tileX},${message.tileY}`,
                  `[${message.slave_id}] ${msg}`, 6000);
                // Resaltar tarjeta del slave en vez de toast
                try { this.highlightSlaveCard(String(message.slave_id), !!ok); } catch {}
                // Si ok y hay coords, marcar como reparados recientemente
                try {
                  if (ok && Array.isArray(message.coords) && message.coords.length) {
                    this.markRecentRepairs(message.coords);
                  }
                } catch {}
                this.requestPreviewRefreshThrottle();
              }
              break;
            
            case 'repair_error':
              this.logOnce(`err:${message.slave_id}:${message.error}`, `‚ùå Slave ${message.slave_id} repair error: ${message.error}`, 8000);
              // Resaltar en rojo en vez de toast
              try { this.highlightSlaveCard(String(message.slave_id), false); } catch {}
              break;
            
            case 'guard_config':
              this.log(`‚öôÔ∏è Guard config received from server`);
              if (message.config) {
                this.guardConfig = message.config;
                if (message.config.autoDistribute !== undefined) {
                  this.autoDistribute = message.config.autoDistribute;
                }
                // Hidratar sets de colores y UI inline
                try {
                  this._preferredColorIds = new Set(Array.isArray(this.guardConfig?.preferredColorIds) ? this.guardConfig.preferredColorIds : []);
                  this._excludedColorIds = new Set(Array.isArray(this.guardConfig?.excludedColorIds) ? this.guardConfig.excludedColorIds : []);
                  this.applyGuardConfigToForm();
                  this.ensureInlineSectionsVisibility();
                  this.renderAllInlineChips();
                } catch {}
                try { this.recomputeRoundPlan(); } catch {}
              }
              break;
            case 'guard_cleared':
              this.log(`üßπ Guard state cleared by server`);
              // Reset preview and counters if it was cleared externally
              try {
                const panel = document.getElementById('preview-panel'); if (panel) panel.style.display='none';
                const fileInput = document.getElementById('project-file') as HTMLInputElement | null; if (fileInput) fileInput.value = '';
                const statusEl = document.getElementById('file-status'); if (statusEl) statusEl.textContent = 'No file selected';
                const detectedEl = document.getElementById('detected-mode'); if (detectedEl) detectedEl.textContent = 'No file loaded - mode will be auto-detected';
                this.projectConfig = null; this.detectedBotMode = null; this.lastPreviewData = null; this.guardPreview = { analysis:null, togglesInitialized:false, show:{correct:true, incorrect:true, missing:true}, area:null };
                ['repaired-pixels','incorrect-pixels','missing-pixels'].forEach(id=>{ const el=document.getElementById(id); if(el) el.textContent='0'; });
              } catch {}
              break;
            case 'guard_upload_sent':
              // Ack desde el servidor confirmando que el upload de guard fue reenviado al slave favorito
              this.log(`üì§ Guard upload ACK ‚Üí fav=${message.sent_to || message.slave_id || 'n/a'} size=${message.originalLength || message.size || 'n/a'} compressed=${message.compressedLength || 'n/a'}`);
              break;
            
            default:
              this.log(`‚ùì Unknown message type: ${message.type}`);
              console.log('Full unknown message:', message);
          }
        }

        async refreshSlaves(retries = 3) {
          try {
            const response = await fetch(`${this.apiBase()}/api/slaves`);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const data = await response.json();
            this.updateSlavesList(data.slaves || []);
          } catch (error) {
            this.log(`Error fetching slaves: ${error}`);
            // Reintentar despu√©s de un breve delay si quedan intentos
            if (retries > 0) {
              setTimeout(() => {
                this.refreshSlaves(retries - 1);
              }, 500);
            }
          }
        }

        updateSlavesList(slaves) {
          this.slaves.clear();
          slaves.forEach(slave => {
            this.slaves.set(slave.id, slave);
          });
          this.displaySlaves();
        }

        displaySlaves() {
          const container = document.getElementById('slaves-list');
          if (!container) return;

          if (this.slaves.size === 0) {
            container.innerHTML = `
              <div class="text-sm text-muted-foreground text-center py-8">
                No slaves connected. Inject Auto-Slave.js in your browser.
              </div>
            `;
            // Deshabilitar acciones dependientes de slaves
            try {
              const oneBatchBtn = document.getElementById('one-batch-btn') as HTMLButtonElement | null; if (oneBatchBtn) oneBatchBtn.disabled = true;
              const oneBatchBtnPreview = document.getElementById('one-batch-btn-preview') as HTMLButtonElement | null; if (oneBatchBtnPreview) oneBatchBtnPreview.disabled = true;
              // legacy guard config button removed
            } catch {}
            try { this.updateConfigPanelEnabledState(); } catch {}
            return;
          }

          const preselected = (id) => {
            if (this._selectedSlavesLocal && this._selectedSlavesLocal.size > 0) return this._selectedSlavesLocal.has(id);
            if (this._selectedSlavesServer && this._selectedSlavesServer.size > 0) return this._selectedSlavesServer.has(id);
            return true;
          };

          container.innerHTML = Array.from(this.slaves.values()).map(slave => `
            <div id="slave-${slave.id}" class="flex items-center justify-between p-3 border rounded-md">
              <div>
                <div class="font-medium text-sm flex items-center space-x-2">
                  <span>${slave.id}</span>
                  <button class="fav-btn" data-id="${slave.id}" title="Marcar como favorito">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="${slave.is_favorite ? '#f59e0b' : 'none'}" stroke="${slave.is_favorite ? '#f59e0b' : 'currentColor'}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <polygon points="12 2 15 9 22 9 17 14 19 21 12 17 5 21 7 14 2 9 9 9 12 2" />
                    </svg>
                  </button>
                </div>
                <div class="text-xs text-muted-foreground">${slave.status || ''}</div>
                <div class="text-xs text-muted-foreground">Charges: <span id="slave-${slave.id}-charges">${(slave.telemetry && typeof slave.telemetry.remaining_charges !== 'undefined') ? ((typeof slave.telemetry.max_charges !== 'undefined' && slave.telemetry.max_charges) ? `${slave.telemetry.remaining_charges}/${slave.telemetry.max_charges}` : slave.telemetry.remaining_charges) : '...'}</span></div>
                <div class="text-[11px] text-muted-foreground mt-1">Quota next: <span id="slave-${slave.id}-quota">0</span></div>
                <div class="w-40 h-1.5 bg-muted rounded mt-1"><div id="slave-${slave.id}-quota-bar" class="h-1.5 bg-blue-500 rounded" style="width:0%"></div></div>
              </div>
              <div class="flex items-center space-x-2">
                <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                <label class="relative inline-flex w-9 h-5 items-center cursor-pointer select-none">
                  <input type="checkbox" class="slave-toggle opacity-0 absolute w-0 h-0" id="slave-toggle-${slave.id}" value="${slave.id}" ${preselected(slave.id) ? 'checked' : ''}>
                  <span data-role="track" class="absolute inset-0 rounded-full transition-colors duration-300 bg-red-500"></span>
                  <span data-role="knob" class="absolute left-0.5 top-1/2 -translate-y-1/2 w-4 h-4 bg-white rounded-full transition-transform duration-300 translate-x-0"></span>
                </label>
              </div>
            </div>
          `).join('');

          // Marcar estilo destacado al favorito
          const fav = Array.from(this.slaves.values()).find(s => s.is_favorite);
          if (fav) {
            const card = document.getElementById(`slave-${fav.id}`);
            if (card) card.classList.add('ring-2','ring-amber-400');
          }

          // Listeners para estrella
          container.querySelectorAll('.fav-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              const target = e.currentTarget as HTMLElement;
              const id = target.getAttribute('data-id');
              if (id) this.setFavoriteSlave(id);
            });
          });

          // Inicializar estado visual de toggles por slave
          const persistSelection = () => {
            try {
              const selected = Array.from(container.querySelectorAll<HTMLInputElement>('.slave-toggle'))
                .filter(cb => cb.checked).map(cb => cb.value);
              localStorage.setItem('selectedSlaves', JSON.stringify(selected));
              fetch(`${this.apiBase()}/api/ui/selected-slaves`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ slave_ids: selected }) }).catch(()=>{});
            } catch {}
          };

          container.querySelectorAll<HTMLInputElement>('.slave-toggle').forEach((input) => {
            // Sincronizar estilos visuales
            this.updateToggleState(input.id, input.checked);
            input.addEventListener('change', () => {
              this.updateToggleState(input.id, input.checked);
              this.updateControlButtons();
              this.recomputeRoundPlan();
              persistSelection();
              // Sincronizar toggle maestro (si alguno est√° off, maestro off)
              const allToggles = Array.from(container.querySelectorAll<HTMLInputElement>('.slave-toggle'));
              const allOn = allToggles.length > 0 && allToggles.every(t => t.checked);
              const master = document.getElementById('toggle-all-slaves') as HTMLInputElement | null;
              if (master) {
                master.checked = allOn;
                this.updateToggleState('toggle-all-slaves', allOn);
              }
            });
          });

          // Recalcular estado del toggle maestro post-render
          const master = document.getElementById('toggle-all-slaves') as HTMLInputElement | null;
          if (master) {
            const allToggles = Array.from(container.querySelectorAll<HTMLInputElement>('.slave-toggle'));
            const allOn = allToggles.length > 0 && allToggles.every(t => t.checked);
            master.checked = allOn;
            this.updateToggleState('toggle-all-slaves', allOn);
            // Listener del maestro
            const masterWrapper = master.parentElement as HTMLElement | null;
            if (masterWrapper && !masterWrapper.getAttribute('data-wired')) {
              masterWrapper.setAttribute('data-wired', '1');
              master.addEventListener('change', () => {
                const desired = master.checked;
                allToggles.forEach(t => {
                  t.checked = desired;
                  this.updateToggleState(t.id, desired);
                });
                this.updateToggleState('toggle-all-slaves', desired);
                this.updateControlButtons();
                this.recomputeRoundPlan();
                persistSelection();
              });
            }
          }

          this.updateControlButtons();
          // Recalcular cuotas despu√©s del render
          this.recomputeRoundPlan();
          // Actualizar estado de panel de config
          try { this.updateConfigPanelEnabledState(); } catch {}
          // Aplicar selecci√≥n del servidor si existe
          if (this._selectedSlavesServer && this._selectedSlavesServer.size > 0) {
            this.applyServerSelection();
          }
        }

        async setFavoriteSlave(slaveId) {
          try {
            await fetch(`${this.apiBase()}/api/slaves/${encodeURIComponent(slaveId)}/favorite`, { method: 'POST' });
            this.log(`‚≠ê ${slaveId} marcado como favorito`);
            await this.refreshSlaves();
          } catch (e) {
            this.log(`Error marcando favorito: ${e}`);
          }
        }

        updateTelemetry(slaveId, telemetry) {
          // Actualizar telemetr√≠a del slave
          if (this.slaves.has(slaveId)) this.slaves.get(slaveId).telemetry = telemetry;

          // Reagrupar m√©tricas agregadas
            let totalRepaired = 0, totalMissing = 0, totalAbsent = 0, totalCharges = 0;
            let guardCorrect = 0, guardIncorrect = 0, guardMissing = 0;

            this.slaves.forEach(slave => {
              if (!slave.telemetry) return;
              totalRepaired += slave.telemetry.repaired_pixels || 0;
              totalMissing += slave.telemetry.missing_pixels || 0;
              totalAbsent += slave.telemetry.absent_pixels || 0;
              totalCharges += slave.telemetry.remaining_charges || 0;
              // M√©tricas Guard si disponibles (del favorito)
              guardCorrect += slave.telemetry.correctPixels || 0;
              guardIncorrect += slave.telemetry.incorrectPixels || 0;
              guardMissing += slave.telemetry.missingPixels || 0;
              // Si preview_data trae an√°lisis m√°s reciente, sobreescribir acumulados (preferimos un solo dataset coherente)
              if (slave.telemetry.preview_data && slave.telemetry.preview_data.analysis) {
                const a = slave.telemetry.preview_data.analysis;
                const c = a.correctPixels ?? a.correct;
                const i = a.incorrectPixels ?? a.incorrect;
                const m = a.missingPixels ?? a.missing;
                if (typeof c === 'number' && typeof i === 'number' && typeof m === 'number') {
                  guardCorrect = c; guardIncorrect = i; guardMissing = m;
                }
              }
            });

            // Actualizar panel realtime existente - usar m√©tricas guard reales
            const rp = document.getElementById('repaired-pixels'); if (rp) rp.textContent = String(guardCorrect);
            const inc = document.getElementById('incorrect-pixels'); if (inc) inc.textContent = String(guardIncorrect);
            const miss = document.getElementById('missing-pixels'); if (miss) miss.textContent = String(guardMissing);
            const rc = document.getElementById('remaining-charges'); if (rc) rc.textContent = String(totalCharges);

            this.updateSlaveCardCharges(slaveId);
            try { this.recomputeRoundPlan(); } catch {}
        }

        updateSlaveCardCharges(slaveId) {
          if (!this.slaves.has(slaveId)) return;
          const slave = this.slaves.get(slaveId);
          const el = document.getElementById(`slave-${slaveId}-charges`);
          if (!el) return;
          const rc = slave?.telemetry?.remaining_charges;
          const mc = slave?.telemetry?.max_charges;
          if (typeof rc === 'number') {
            el.textContent = (typeof mc === 'number' && mc > 0) ? `${rc}/${mc}` : `${rc}`;
          } else {
            el.textContent = '...';
          }
          // Intentar actualizar barra de cuota si existe plan
          try {
            const val = this.currentRoundPlan?.[slaveId] || 0;
            const cap = Math.max(1, Number(rc) || 0);
            this.updateSlaveCardQuota(slaveId, val, cap ? (val / cap) : 0);
          } catch {}
        }

        updateSlaveStatus(slaveId, status) {
          if (this.slaves.has(slaveId)) {
            this.slaves.get(slaveId).status = status;
            this.displaySlaves();
          }
        }

        applyServerSelection() {
          if (!this._selectedSlavesServer || !(this._selectedSlavesServer instanceof Set)) return;
          const checkboxes = document.querySelectorAll<HTMLInputElement>('.slave-toggle');
          checkboxes.forEach(cb => {
            const should = this._selectedSlavesServer.has(cb.value);
            cb.checked = should;
            this.updateToggleState(cb.id, should);
          });
          // Actualizar master toggle
          const all = Array.from(checkboxes);
          const master = document.getElementById('toggle-all-slaves') as HTMLInputElement | null;
          if (master) {
            const allOn = all.length > 0 && all.every(c => c.checked);
            master.checked = allOn;
            this.updateToggleState('toggle-all-slaves', allOn);
          }
          this.updateControlButtons();
          this.recomputeRoundPlan();
        }

        setupEventListeners() {
          document.getElementById('start-btn').addEventListener('click', () => this.startSession());
          document.getElementById('pause-btn').addEventListener('click', () => this.pauseSession());
          document.getElementById('stop-btn').addEventListener('click', () => this.stopSession());
          const oneBatchBtn = document.getElementById('one-batch-btn');
          if (oneBatchBtn) {
            oneBatchBtn.addEventListener('click', () => this.sendOneBatch());
          }
          const oneBatchBtnPreview = document.getElementById('one-batch-btn-preview');
          if (oneBatchBtnPreview) {
            oneBatchBtnPreview.addEventListener('click', () => this.sendOneBatch());
          }
          
          // Modal legacy removed: no guard config button needed
          
          // Preview panel controls
          // Bot√≥n cerrar eliminado: el panel de preview ya no se puede cerrar
          
          const fitZoomBtn = document.getElementById('fit-zoom');
          if (fitZoomBtn) {
            fitZoomBtn.addEventListener('click', () => this.fitZoom());
          }
          
          const zoomSlider = document.getElementById('zoom-slider');
          const zoomLevel = document.getElementById('zoom-level');
          if (zoomSlider && zoomLevel) {
            zoomSlider.addEventListener('input', (e) => {
              const desired = parseFloat((e.target as HTMLInputElement).value);
              this.setZoom(desired); // setZoom ya clampa y sincroniza UI
            });
          }
          
          // File input change handler for auto-detection
          document.getElementById('project-file').addEventListener('change', (e) => this.handleFileChange(e));

          // Clear project
          const clearBtn = document.getElementById('clear-project-btn');
          if (clearBtn) clearBtn.addEventListener('click', () => this.clearProject());

          // Resizer events
          const resizer = document.getElementById('preview-resizer');
          if (resizer) {
            let isResizing = false; let startY = 0; let startH = 0;
            resizer.addEventListener('mousedown', (e) => {
              const content = document.getElementById('preview-content') as HTMLElement | null;
              if (!content) return;
              isResizing = true; startY = e.clientY; startH = content.offsetHeight;
              document.body.style.cursor = 'ns-resize';
              document.addEventListener('mousemove', onMove);
              document.addEventListener('mouseup', onUp);
            });
            const onMove = (e: MouseEvent) => {
              if (!isResizing) return; const content = document.getElementById('preview-content') as HTMLElement | null; if (!content) return;
              const delta = e.clientY - startY; const next = Math.max(520, Math.min(window.innerHeight * 0.95, startH + delta));
              content.style.height = `${Math.round(next)}px`;
              this.persistPreviewPreferredHeight(Math.round(next));
              this.fitZoom();
            };
            const onUp = () => { if (!isResizing) return; isResizing = false; document.body.style.cursor = 'default'; document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); };
          }
          
          // Window resize handler for preview
          window.addEventListener('resize', () => {
            const previewPanel = document.getElementById('preview-panel');
            if (previewPanel && previewPanel.style.display !== 'none') {
              this.adjustPreviewSize();
            }
          });

          // Logs collapsible toggle
          const logsToggle = document.getElementById('logs-toggle');
          const logsCaret = document.getElementById('logs-caret');
          const logsWrapper = document.getElementById('logs-wrapper');
          if (logsToggle && logsCaret && logsWrapper) {
            logsToggle.addEventListener('click', () => {
              const open = logsWrapper.style.maxHeight && parseInt(logsWrapper.style.maxHeight) > 0;
              if (open) {
                logsWrapper.style.maxHeight = '0px';
                logsCaret.style.transform = 'rotate(-90deg)';
              } else {
                logsWrapper.style.maxHeight = '220px';
                logsCaret.style.transform = 'rotate(0deg)';
              }
            });
          }
          
          document.addEventListener('change', (e) => {
            const target = e.target as HTMLElement | null;
            if (target && target.classList && target.classList.contains('slave-toggle')) {
              this.updateControlButtons();
              this.recomputeRoundPlan();
            }
          });
        }

        // Persist preferred height helpers
        persistPreviewPreferredHeight(h:number){ try { localStorage.setItem('previewPanel.height', String(h)); } catch {} }
        restorePreviewPreferredHeight(){
          try { const v = parseInt(localStorage.getItem('previewPanel.height') || '0', 10); if (v>0) { const content = document.getElementById('preview-content') as HTMLElement | null; if (content) content.style.height = `${v}px`; } } catch {}
        }

        detectProjectMode(json:any, fileName:string){
          // Prioridad expl√≠cita
            if(json && typeof json.mode === 'string'){
              const m = json.mode.toLowerCase();
              if(m.startsWith('guard')) return 'Guard';
              if(m.startsWith('image')) return 'Image';
            }
            // Se√±ales de Guard (protectionData, protectionArea, protectedPixels, originalPixels, splitInfo)
            const guardSignals = [
              json?.protectionData,
              json?.protectionArea,
              json?.originalPixels,
              json?.protectionData?.area,
              json?.protectionData?.protectedPixels,
            ].some(Boolean);
            // Se√±ales de Image (imageData con width/height, remainingPixels, pixels, fullPixelData)
            const imageSignals = [
              json?.imageData?.width,
              json?.imageData?.height,
              json?.imageData?.fullPixelData,
              Array.isArray(json?.remainingPixels) && json.remainingPixels.length>0,
              Array.isArray(json?.imageData?.fullPixelData) && json.imageData.fullPixelData.length>0,
              Array.isArray(json?.pixels) && json.pixels.length>0
            ].some(Boolean);
            if(guardSignals && !imageSignals) return 'Guard';
            if(imageSignals && !guardSignals) return 'Image';
            // Heur√≠stica por nombre archivo
            const lower = fileName.toLowerCase();
            if(/guard|protection/.test(lower)) return 'Guard';
            if(/image|progress|collage/.test(lower)) return 'Image';
            // Empate: preferir Guard si protectionData existe
            if(guardSignals) return 'Guard';
            if(imageSignals) return 'Image';
            return 'Image'; // fallback
        }

    hidePreviewPanel(){ const panel=document.getElementById('preview-panel'); if(panel) panel.style.display='none'; }
        showPreviewFromProject(json:any){
          try{
      const panel=document.getElementById('preview-panel'); if(panel){ panel.style.display='block'; }
            
            const canvas=document.getElementById('preview-canvas') as HTMLCanvasElement|null;
            if(canvas && json?.imageData?.width && json?.imageData?.height && Array.isArray(json?.imageData?.fullPixelData)){
              const w=json.imageData.width; const h=json.imageData.height; canvas.width=w; canvas.height=h; const ctx=canvas.getContext('2d'); if(ctx){
                const imgData=ctx.createImageData(w,h);
                json.imageData.fullPixelData.slice(0,w*h).forEach(p=>{ if(p && p.x>=0&&p.y>=0&&p.x<w&&p.y<h){ const idx=(p.y*w+p.x)*4; imgData.data[idx]=p.r||0; imgData.data[idx+1]=p.g||0; imgData.data[idx+2]=p.b||0; imgData.data[idx+3]=255; }});
                ctx.putImageData(imgData,0,0);
              }
            }
            
            // Adjust preview size and auto-fit zoom after rendering
            setTimeout(() => { this.restorePreviewPreferredHeight(); this.adjustPreviewSize(); this.fitZoom(); }, 100);
            try { this.updateControlButtons(); } catch {}
          }catch(e){ this.log('‚ö†Ô∏è Preview render error: '+e.message); }
        }

        showGuardPreviewFromProject(json:any){
          try {
            const panel=document.getElementById('preview-panel'); if(panel){ panel.style.display='block'; }
            const area = json.protectionData?.area || json.protectionArea;
            const total = json.protectionData?.protectedPixels || (Array.isArray(json.originalPixels)? json.originalPixels.length:0);
            
            if(area && Array.isArray(json.originalPixels)){
              const originalMap = new Map();
              json.originalPixels.forEach(p=>{ if(p&&p.x!==undefined&&p.y!==undefined) originalMap.set(`${p.x},${p.y}`, {r:p.r,g:p.g,b:p.b}); });
              const analysis = { correct:new Map(), incorrect:new Map(), missing: originalMap, originalPixels: originalMap, currentPixels: new Map() };
              this.guardPreview.analysis = analysis; this.guardPreview.area = area;
              this.renderGuardPreviewCanvas({analysis, area});
              this.initGuardPreviewToggles();
              
              // Adjust preview size and auto-fit zoom after rendering
              setTimeout(() => { this.restorePreviewPreferredHeight(); this.adjustPreviewSize(); this.fitZoom(); }, 100);
              try { this.updateControlButtons(); } catch {}
            }
          } catch(e){ this.log('‚ö†Ô∏è Guard preview error: '+e.message); }
        }

        async clearProject(){
          try {
            const r = await fetch(`${this.apiBase()}/api/projects/clear-all`, { method: 'POST' });
            if(!r.ok) throw new Error(`HTTP ${r.status}`);
            this.log('üßπ Limpieza global solicitada');
          } catch(e){
            this.log(`‚ö†Ô∏è Error calling /api/projects/clear-all: ${e?.message || e}`);
          }
          
          // NUEVO: Detener an√°lisis Guard en todos los slaves para evitar preview persistente
          try {
            await fetch(`${this.apiBase()}/api/guard/clear`, { method: 'POST' });
            this.log('üõ°Ô∏è Guard state cleared en slaves');
          } catch(e){
            this.log(`‚ö†Ô∏è Error clearing guard state: ${e?.message || e}`);
          }
          
          // Reset inmediato local
          try {
            const statusEl = document.getElementById('file-status'); if (statusEl) statusEl.textContent = 'No file selected';
            
            // NUEVO: Limpiar el input de archivo para permitir recargar el mismo archivo
            const fileInput = document.getElementById('project-file') as HTMLInputElement | null; 
            if (fileInput) fileInput.value = '';
            
            const detectedEl = document.getElementById('detected-mode'); 
            if (detectedEl) detectedEl.textContent = 'No file loaded - mode will be auto-detected';
            
            this.activeProject = null; this.projectConfig = null; this.detectedBotMode = null;
            this.lastPreviewData = null; this.previewChanges = []; this.previewMeta = {};
            this.guardPreview = { analysis:null, togglesInitialized:false, show:{correct:true, incorrect:true, missing:true}, area:null };
            const panel = document.getElementById('preview-panel') as HTMLElement | null; if (panel) panel.style.display = 'none';
            ['repaired-pixels','incorrect-pixels','missing-pixels'].forEach(id=>{ const el=document.getElementById(id); if(el) el.textContent='0'; });
            try { localStorage.removeItem('previewPanel.height'); } catch {}
            this.updateControlButtons();
          } catch {}
          this.renderPreview();
        }

        createToggle(id, labelText, checked = false) {
          return `
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; padding: 8px 0;">
              <span style="color: #eee; font-size: 14px; flex: 1;">${labelText}</span>
              <label class="toggle-switch" style="position: relative; display: inline-block; width: 50px; height: 26px; margin-left: 10px;">
                <input type="checkbox" id="${id}" ${checked ? 'checked' : ''} style="opacity: 0; width: 0; height: 0;">
                <span class="toggle-slider" style="
                  position: absolute;
                  cursor: pointer;
                  top: 0;
                  left: 0;
                  right: 0;
                  bottom: 0;
                  background-color: ${checked ? '#22c55e' : '#ef4444'};
                  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                  border-radius: 13px;
                  border: 1px solid ${checked ? '#16a34a' : '#dc2626'};
                "></span>
                <span class="toggle-knob" style="
                  position: absolute;
                  height: 20px;
                  width: 20px;
                  left: ${checked ? '27px' : '3px'};
                  top: 3px;
                  background-color: white;
                  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                  border-radius: 50%;
                  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                "></span>
              </label>
            </div>
          `;
        }

        createCompactToggle(id, labelText, checked = false) {
          return `
            <div class="flex items-center justify-between py-1">
              <span class="text-xs text-gray-300">${labelText}</span>
              <label class="relative inline-flex w-9 h-5 items-center cursor-pointer select-none">
                <input type="checkbox" id="${id}" ${checked ? 'checked' : ''} class="opacity-0 absolute w-0 h-0">
                <span data-role="track" class="absolute inset-0 rounded-full transition-colors duration-300 ${checked ? 'bg-green-500' : 'bg-red-500'}"></span>
                <span data-role="knob" class="absolute left-0.5 top-1/2 -translate-y-1/2 w-4 h-4 bg-white rounded-full transition-transform duration-300 ${checked ? 'translate-x-4' : 'translate-x-0'}"></span>
              </label>
            </div>
          `;
        }

        updateToggleState(toggleId, checked) {
          const toggle = document.getElementById(toggleId);
          if (!toggle) return;

          // Prefer the compact version using data-role markers
          const wrapper = toggle.parentElement as HTMLElement | null;
          const compactSlider = wrapper?.querySelector('[data-role="track"]') as HTMLElement | null;
          const compactKnob = wrapper?.querySelector('[data-role\="knob\"]') as HTMLElement | null;

          if (compactSlider && compactKnob) {
            compactSlider.className = `absolute inset-0 rounded-full transition-colors duration-300 ${checked ? 'bg-green-500' : 'bg-red-500'}`;
            compactKnob.className = `absolute left-0.5 top-1/2 -translate-y-1/2 w-4 h-4 bg-white rounded-full transition-transform duration-300 ${checked ? 'translate-x-4' : 'translate-x-0'}`;
            return;
          }

          // Fallback al estilo antiguo (por si hay legacy)
          const slider = wrapper?.querySelector('.toggle-slider') as HTMLElement | null;
          const knob = wrapper?.querySelector('.toggle-knob') as HTMLElement | null;
          if (slider && knob) {
            slider.style.backgroundColor = checked ? '#22c55e' : '#ef4444';
            slider.style.borderColor = checked ? '#16a34a' : '#dc2626';
            knob.style.left = checked ? '27px' : '3px';
          }
        }

        setupGuardPreviewControls() {
          // Control de zoom (usar los controles actuales si existen; fallback a gp-*)
          const zoomSlider = (document.getElementById('zoom-slider') as HTMLInputElement) || (document.getElementById('gp-zoom-slider') as HTMLInputElement);
          const zoomValue = document.getElementById('zoom-level') || document.getElementById('gp-zoom-value');
          const autoFitBtn = document.getElementById('fit-zoom') || document.getElementById('gp-auto-fit');
          const canvas = document.getElementById('preview-canvas') as HTMLCanvasElement;
          
          if (zoomSlider && zoomValue && canvas) {
            zoomSlider.addEventListener('input', (e) => {
              const zoom = parseFloat((e.target as HTMLInputElement).value);
              this.setZoom(zoom);
              (zoomValue as HTMLElement).textContent = `${Math.round(zoom * 100)}%`;
            });
          }
          
          // Auto-ajuste de zoom
          if (autoFitBtn) {
            autoFitBtn.addEventListener('click', () => this.fitZoom());
          }
          
          // Toggles de visualizaci√≥n
          const toggleIds = ['gp-show-correct', 'gp-show-incorrect', 'gp-show-missing'];
          toggleIds.forEach(id => {
            const toggle = document.getElementById(id) as HTMLInputElement;
            if (!toggle) return;
            
            // Actualizar estado visual inicial
            this.updateToggleState(id, toggle.checked);
            
            toggle.addEventListener('change', () => {
              this.updateToggleState(id, toggle.checked);
              
              // Actualizar estado interno
              this.guardPreview.show.correct = (document.getElementById('gp-show-correct') as HTMLInputElement)?.checked || false;
              this.guardPreview.show.incorrect = (document.getElementById('gp-show-incorrect') as HTMLInputElement)?.checked || false;
              this.guardPreview.show.missing = (document.getElementById('gp-show-missing') as HTMLInputElement)?.checked || false;
              
              // Re-renderizar
              if (this.guardPreview.analysis && this.guardPreview.area) {
                this.renderGuardPreviewCanvas({analysis: this.guardPreview.analysis, area: this.guardPreview.area});
              }
            });
          });
          
          // Agregar interacciones de canvas mejoradas
          this.setupCanvasInteractions(canvas);
        }

  setupCanvasInteractions(canvas) {
          if (!canvas) return;
          
          const canvasContainer = canvas.parentElement;
          if (!canvasContainer) return;
          
          // Configurar contenedor para scroll
          canvasContainer.style.overflow = 'auto';
          canvasContainer.style.position = 'relative';
          
          // Variables para pan
          let isPanning = false;
          let startX = 0;
          let startY = 0;
          let scrollLeftStart = 0;
          let scrollTopStart = 0;
          
          // Pan con mouse
          canvasContainer.addEventListener('mousedown', (e) => {
            isPanning = true;
            startX = e.clientX;
            startY = e.clientY;
            scrollLeftStart = canvasContainer.scrollLeft;
            scrollTopStart = canvasContainer.scrollTop;
            canvasContainer.style.cursor = 'grabbing';
          });
          
          document.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            
            canvasContainer.scrollLeft = scrollLeftStart - dx;
            canvasContainer.scrollTop = scrollTopStart - dy;
          });
          
          document.addEventListener('mouseup', () => {
            isPanning = false;
            canvasContainer.style.cursor = 'grab';
          });
          
          // Zoom con rueda del mouse (usa setZoom y el slider actual)
          canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const slider = (document.getElementById('zoom-slider') as HTMLInputElement) || (document.getElementById('gp-zoom-slider') as HTMLInputElement);
            const label = document.getElementById('zoom-level') || document.getElementById('gp-zoom-value');
            if (!slider || !label) return;
            const factor = 1.1;
            const oldZoom = parseFloat(slider.value || '1') || 1;
            const proposed = oldZoom * (e.deltaY < 0 ? factor : 1 / factor);
            this.setZoom(proposed); // clampa internamente al m√°ximo permitido por la ventana
          }, { passive: false });
        }

        initGuardPreviewToggles(){
          if(this.guardPreview.togglesInitialized) return;
          
          // Buscar el contenedor correcto
          const container = document.getElementById('guard-preview-controls');
          if(!container) {
            this.log('‚ö†Ô∏è Container guard-preview-controls not found');
            return;
          }
          
          // Limpiar contenedor
          container.innerHTML = '';
          
          const controlsHTML = `
            <div class="space-y-2">
              ${this.createCompactToggle('gp-show-correct', '‚úÖ Correctos', this.guardPreview.show.correct)}
              ${this.createCompactToggle('gp-show-incorrect', '‚ùå Incorrectos', this.guardPreview.show.incorrect)}
              ${this.createCompactToggle('gp-show-missing', '‚ö™ Faltantes', this.guardPreview.show.missing)}
            </div>
          `;
          
          container.innerHTML = controlsHTML;
          this.setupGuardPreviewControls();
          this.guardPreview.togglesInitialized = true;
        }

        updatePreviewFromSlave(slaveId, data){
          try {
            if(!data) return; 
            this.lastPreviewData = data;
            this.log(`üîÑ Processing preview data from ${slaveId}: ${JSON.stringify(Object.keys(data))}`);
            
            // Normalizar √°rea: slave modular env√≠a protectedArea
            const area = data.protectedArea || data.area;
            if (!area) {
              this.log('‚ö†Ô∏è No area data found in preview');
              return;
            }
            
            this.log(`üìç Area: (${area.x1},${area.y1}) ‚Üí (${area.x2},${area.y2})`);
            
            // Funci√≥n helper para convertir arrays a Maps
            const toMap = (arr) => {
              const m = new Map();
              if (Array.isArray(arr)) {
                arr.forEach(p => {
                  if (p && p.x !== undefined && p.y !== undefined) {
                    m.set(`${p.x},${p.y}`, {
                      r: p.r || 0, 
                      g: p.g || 0, 
                      b: p.b || 0,
                      originalR: p.originalR,
                      originalG: p.originalG, 
                      originalB: p.originalB
                    });
                  }
                });
              }
              return m;
            };
            
            // Convertir listas de p√≠xeles a Maps - usar nombres correctos del m√≥dulo Guard
            const correct = toMap(data.correctPixelsList || []);
            const incorrect = toMap(data.incorrectPixelsList || []); 
            const missing = toMap(data.missingPixelsList || []);
            const originalPixels = toMap(data.originalPixels || []);
            
            this.log(`üî¢ Raw data lengths - CorrectList:${(data.correctPixelsList || []).length}, IncorrectList:${(data.incorrectPixelsList || []).length}, MissingList:${(data.missingPixelsList || []).length}, OriginalList:${(data.originalPixels || []).length}`);
            this.log(`üî¢ Converted pixels - Original:${originalPixels.size}, Correct:${correct.size}, Incorrect:${incorrect.size}, Missing:${missing.size}`);
            
            const analysis = { correct, incorrect, missing, originalPixels };
            
            // Construir lista de cambios para recomputeRoundPlan
            const changes = [];
            // Agregar p√≠xeles incorrectos como cambios tipo 'incorrect'
            if (Array.isArray(data.incorrectPixelsList)) {
              data.incorrectPixelsList.forEach(p => {
                if (p && typeof p.x !== 'undefined' && typeof p.y !== 'undefined') {
                  changes.push({
                    type: 'incorrect',
                    x: p.x,
                    y: p.y,
                    expectedColor: p.originalR !== undefined ? 
                      ((p.originalR & 0xFF) << 16) | ((p.originalG & 0xFF) << 8) | (p.originalB & 0xFF) : 
                      (p.color || 0),
                    color: p.r !== undefined ? 
                      ((p.r & 0xFF) << 16) | ((p.g & 0xFF) << 8) | (p.b & 0xFF) : 
                      (p.currentColor || 0)
                  });
                }
              });
            }
            // Agregar p√≠xeles faltantes como cambios tipo 'missing'
            if (Array.isArray(data.missingPixelsList)) {
              data.missingPixelsList.forEach(p => {
                if (p && typeof p.x !== 'undefined' && typeof p.y !== 'undefined') {
                  changes.push({
                    type: 'missing',
                    x: p.x,
                    y: p.y,
                    expectedColor: p.r !== undefined ? 
                      ((p.r & 0xFF) << 16) | ((p.g & 0xFF) << 8) | (p.b & 0xFF) : 
                      (p.color || 0)
                  });
                }
              });
            }
            
            // Almacenar datos con la lista de cambios construida
            this.lastPreviewData = { ...data, changes };
            this.log(`üìù Built changes list: ${changes.length} total (incorrect: ${data.incorrectPixelsList?.length || 0}, missing: ${data.missingPixelsList?.length || 0})`);
            
            // Almacenar y renderizar
            this.guardPreview.analysis = analysis; 
            this.guardPreview.area = area; 
            this.renderGuardPreviewCanvas({analysis, area});
            
          } catch(err){ 
            this.log('‚ö†Ô∏è updatePreviewFromSlave error: ' + err.message); 
            console.error('Preview processing error:', err, data);
          }
        }

        renderGuardPreviewCanvas(payload){
          try {
            if(!payload||!payload.analysis||!payload.area) return;
            // Si a√∫n no hay modo detectado, inferir Guard al renderizar este preview
            if (!this.detectedBotMode) {
              this.detectedBotMode = 'Guard';
              const detectedEl = document.getElementById('detected-mode');
              if (detectedEl) detectedEl.textContent = `Detected mode: ${this.detectedBotMode}`;
              try { this.updateControlButtons(); } catch {}
            }
            this.initGuardPreviewToggles();
            const panel=document.getElementById('preview-panel'); if(panel) panel.style.display='block';
            const area=payload.area;
            
            // Calcular el total real de p√≠xeles de todas las categor√≠as
            const correctCount = payload.analysis.correct?.size || 0;
            const incorrectCount = payload.analysis.incorrect?.size || 0;
            const missingCount = payload.analysis.missing?.size || 0;
            const originalCount = payload.analysis.originalPixels?.size || 0;
            const total = Math.max(originalCount, correctCount + incorrectCount + missingCount);
            
            // Actualizar estad√≠sticas en el panel
            this.updateGuardStatistics(payload.analysis);
            
            this.initGuardPreviewToggles();
            const canvas=document.getElementById('preview-canvas') as HTMLCanvasElement|null; 
            if(!canvas) return; 
            
            const width=area.x2-area.x1+1; 
            const height=area.y2-area.y1+1; 
            
            this.log(`üé® Rendering ${total} pixels in ${width}x${height} canvas (Correct:${correctCount}, Incorrect:${incorrectCount}, Missing:${missingCount})`);
            
            // Configurar canvas
            canvas.width = width;
            canvas.height = height;
            
            // No modificar style.width/height: el escalado lo gestiona transform/fitZoom
            
            const ctx = canvas.getContext('2d');
            if(!ctx) return;
            
            const imageData = ctx.createImageData(width, height);
            
            // Inicializar con fondo gris claro
            for (let i = 0; i < imageData.data.length; i += 4) {
              imageData.data[i] = 240;     // R
              imageData.data[i + 1] = 240; // G
              imageData.data[i + 2] = 240; // B
              imageData.data[i + 3] = 60;  // Alpha bajo para fondo sutil
            }
            
            // Obtener estado de los toggles
            const showCorrectEl = document.getElementById('gp-show-correct') as HTMLInputElement;
            const showIncorrectEl = document.getElementById('gp-show-incorrect') as HTMLInputElement;
            const showMissingEl = document.getElementById('gp-show-missing') as HTMLInputElement;
            
            const showCorrect = showCorrectEl ? showCorrectEl.checked : this.guardPreview.show.correct;
            const showIncorrect = showIncorrectEl ? showIncorrectEl.checked : this.guardPreview.show.incorrect;
            const showMissing = showMissingEl ? showMissingEl.checked : this.guardPreview.show.missing;
            
            this.log(`üéõÔ∏è Display states - Correct: ${showCorrect}, Incorrect: ${showIncorrect}, Missing: ${showMissing}`);
            
            // Funci√≥n para dibujar p√≠xel
            const drawPixel = (x, y, r, g, b, a = 255) => {
              const index = ((y - area.y1) * width + (x - area.x1)) * 4;
              if (index >= 0 && index < imageData.data.length - 3) {
                imageData.data[index] = r;
                imageData.data[index + 1] = g;
                imageData.data[index + 2] = b;
                imageData.data[index + 3] = a;
              }
            };
            
            // Dibujar p√≠xeles originales como fondo
            if (payload.analysis.originalPixels) {
              for (const [key, pixel] of payload.analysis.originalPixels) {
                const [x, y] = key.split(',').map(Number);
                drawPixel(x, y, pixel?.r ?? 128, pixel?.g ?? 128, pixel?.b ?? 128, 255);
              }
            }

            // Dibujar p√≠xeles correctos (verde) si est√° habilitado
            if (showCorrect && payload.analysis.correct) {
              for (const [key] of payload.analysis.correct) {
                const [x, y] = key.split(',').map(Number);
                drawPixel(x, y, 0, 200, 0, 220);
              }
            }

            // Dibujar p√≠xeles incorrectos (rojo) si est√° habilitado
            if (showIncorrect && payload.analysis.incorrect) {
              for (const [key] of payload.analysis.incorrect) {
                const [x, y] = key.split(',').map(Number);
                drawPixel(x, y, 220, 30, 30, 230);
              }
            }

            // Dibujar p√≠xeles faltantes (amarillo) si est√° habilitado
            if (showMissing && payload.analysis.missing) {
              for (const [key] of payload.analysis.missing) {
                const [x, y] = key.split(',').map(Number);
                drawPixel(x, y, 240, 210, 0, 220);
              }
            }

            // Volcar al canvas y ajustar tama√±o/zoom
            ctx.putImageData(imageData, 0, 0);
            try { this.updateGuardStatistics(payload.analysis); } catch {}
            setTimeout(() => { this.restorePreviewPreferredHeight(); this.adjustPreviewSize(); this.fitZoom(); }, 50);
          } catch(err){ 
            this.log('‚ö†Ô∏è renderGuardPreviewCanvas error: ' + err.message); 
            console.error('Canvas render error:', err, payload);
          }
        }

        // Manejo de carga de archivo de proyecto (Image o Guard)
        handleFileChange(e){
          try {
            const input = e?.target;
            const file = input && input.files && input.files[0];
            const statusEl = document.getElementById('file-status');
            const detectedEl = document.getElementById('detected-mode');
            if (!file) { if (statusEl) statusEl.textContent = 'No file selected'; return; }
            if (statusEl) statusEl.textContent = 'Reading...';
            const reader = new FileReader();
            reader.onload = async () => {
              try {
                const text = String(reader.result || '');
                const json = JSON.parse(text);
                this.projectConfig = json;
                const mode = this.detectProjectMode(json, file.name);
                this.detectedBotMode = mode;
                if (detectedEl) detectedEl.textContent = mode ? `Detected mode: ${mode}` : 'Unknown mode';
                if (statusEl) statusEl.textContent = `Loaded: ${file.name}`;
                // Mostrar preview seg√∫n modo
                if (mode === 'Image') this.showPreviewFromProject(json);
                else this.showGuardPreviewFromProject(json);
                // Enviar guardData al favorito para rehidratar (si aplica)
                try {
                  if (mode === 'Guard') {
                    fetch(`${this.apiBase()}/api/guard/upload`, {
                      method: 'POST', headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ filename: file.name, data: json })
                    }).then(r=>r.json()).then(resp=>{
                      this.log(`üì§ Guard upload sent ‚Üí fav=${resp.sent_to||'n/a'} pixels=${json?.originalPixels?.length||json?.protectionData?.protectedPixels||0}`);
                    }).catch(err=>{ this.log('‚ùå Guard upload error: '+(err?.message||err)); });
                  }
                } catch(upErr){ this.log('‚ö†Ô∏è Upload exception: '+(upErr?.message||upErr)); }
                this.updateControlButtons();
              } catch (parseErr) {
                if (statusEl) statusEl.textContent = 'Invalid JSON';
                this.log('‚ùå JSON parse error: ' + (parseErr?.message || parseErr));
              }
            };
            reader.onerror = () => { this.projectConfig = null; this.detectedBotMode = null; if (statusEl) statusEl.textContent='Read error'; this.updateControlButtons(); this.log('‚ùå File read error'); };
            reader.readAsText(file);
          } catch (ex) {
            this.log('‚ùå Unexpected handleFileChange error: '+ (ex?.message || ex));
          }
        }

        // Actualiza contadores b√°sicos del panel de telemetr√≠a para Guard
        updateGuardStatistics(analysis){
          try {
            const correctCount = analysis?.correct?.size || 0;
            const incorrectCount = analysis?.incorrect?.size || 0;
            const missingCount = analysis?.missing?.size || 0;
            const rp = document.getElementById('repaired-pixels'); if (rp) rp.textContent = String(correctCount);
            const inc = document.getElementById('incorrect-pixels'); if (inc) inc.textContent = String(incorrectCount);
            const miss = document.getElementById('missing-pixels'); if (miss) miss.textContent = String(missingCount);
            const total = (analysis?.originalPixels?.size || (correctCount + incorrectCount + missingCount));
            const acc = total ? (correctCount/total*100) : 0;
            this.updateOverallProgressBar(acc);
          } catch {}
        }

        updateControlButtons() {
          const selectedSlaves = document.querySelectorAll<HTMLInputElement>('.slave-toggle:checked');
          // Inferir modo si a√∫n no est√° definido, a partir del estado disponible
          if (!this.detectedBotMode) {
            const looksGuard = !!(this.guardPreview?.analysis || (this.lastPreviewData && (this.lastPreviewData.correctPixelsList || this.lastPreviewData.incorrectPixelsList || this.lastPreviewData.missingPixelsList || this.lastPreviewData.analysis || this.lastPreviewData.protectedArea || this.lastPreviewData.area)));
            const looksImage = !!(this.projectConfig?.imageData || (this.lastPreviewData && this.lastPreviewData.imageData));
            if (looksGuard) this.detectedBotMode = 'Guard';
            else if (looksImage) this.detectedBotMode = 'Image';
            if (this.detectedBotMode) { const dm = document.getElementById('detected-mode'); if (dm) dm.textContent = `Detected mode: ${this.detectedBotMode}`; }
          }
          const hasMode = this.detectedBotMode !== null;
          const hasSelected = selectedSlaves.length > 0;
          // Regla extra para Guard: requiere favorito y guard data cargado (preview u originalPixels)
          let guardReady = true;
          if (this.detectedBotMode === 'Guard') {
            const favId = this.getFavoriteSlaveId();
            const hasFav = !!favId;
            // Permitimos empezar si hay config/proyecto cargado aunque a√∫n no tengamos preview local; el favorito podr√° solicitarlo
            const hasProject = !!this.projectConfig;
            const hasGuardData = !!(this.guardPreview?.analysis || (this.lastPreviewData && (this.lastPreviewData.originalPixels || this.lastPreviewData.analysis)));
            guardReady = hasFav && (hasProject || hasGuardData);
          }
          // Si hay sesi√≥n corriendo, Start siempre deshabilitado
          const isRunning = this.sessionStatus === 'running';
          const isPaused = this.sessionStatus === 'paused';
          const baseCanStart = hasSelected && hasMode && guardReady;
          const canStart = !isRunning && baseCanStart; // en paused, permitimos Start si base ok
          const startBtn = document.getElementById('start-btn') as HTMLButtonElement | null; if (startBtn) startBtn.disabled = !canStart;
          
          // Enable distribute repairs button if there are connected slaves
          const hasSlaves = this.slaves.size > 0;
          const distBtn = document.getElementById('distribute-repairs-btn') as HTMLButtonElement | null; if (distBtn) distBtn.disabled = !hasSlaves;
          const oneBatchBtn = document.getElementById('one-batch-btn') as HTMLButtonElement | null; if (oneBatchBtn) oneBatchBtn.disabled = !hasSlaves;
          const oneBatchBtnPreview = document.getElementById('one-batch-btn-preview') as HTMLButtonElement | null; if (oneBatchBtnPreview) oneBatchBtnPreview.disabled = !hasSlaves;
          // legacy guard config button removed
        }

  async startSession() {
          // Mostrar spinner y deshabilitar bot√≥n
          this.showStartSpinner();
          
          const selectedSlaves = Array.from(document.querySelectorAll<HTMLInputElement>('.slave-toggle:checked')).map(cb => cb.value);
          try { localStorage.setItem('selectedSlaves', JSON.stringify(selectedSlaves)); } catch {}
          try { await fetch(`${this.apiBase()}/api/ui/selected-slaves`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ slave_ids: selectedSlaves }) }); } catch {}
          const strategy = (document.getElementById('gc-chargeStrategy') as HTMLSelectElement | null)?.value || this.guardConfig?.chargeStrategy || 'greedy';

          if (!selectedSlaves.length || !this.detectedBotMode) {
            this.log('Please select slaves and load a project file');
            this.hideStartSpinner();
            return;
          }

          try {
            this.log(`üöÄ Starting session with mode: ${this.detectedBotMode}`);
            
            // Create project
            let projectConfig = { 
              mode: this.detectedBotMode, 
              config: this.projectConfig || {} 
            };

            const projectResponse = await fetch(`${this.apiBase()}/api/projects`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name: `Session ${Date.now()}`, ...projectConfig })
            });
            
            const projectData = await projectResponse.json();
            this.log(`üìÅ Project created: ${projectData.project_id}`);

            // Create session
            const sessionResponse = await fetch(`${this.apiBase()}/api/sessions`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                project_id: projectData.project_id,
                slave_ids: selectedSlaves,
                strategy: strategy
              })
            });
            
            const sessionData = await sessionResponse.json();
            this.currentSession = sessionData.session_id;
            this.log(`üéØ Session created: ${this.currentSession}`);

            // Start session (continuous orchestrator)
            const startRes = await fetch(`${this.apiBase()}/api/sessions/${this.currentSession}/start`, { method: 'POST' });
            const startJs = await startRes.json();
            const totalRem = startJs?.total_remaining ?? 0;
            this.log(`‚úÖ Session started; total remaining charges: ${totalRem}`);
            this.sessionStatus = 'running';
            const rc = document.getElementById('remaining-charges'); if (rc) rc.textContent = String(totalRem);
            const pauseBtn = document.getElementById('pause-btn') as HTMLButtonElement | null; if (pauseBtn) pauseBtn.disabled = false;
            const stopBtn = document.getElementById('stop-btn') as HTMLButtonElement | null; if (stopBtn) stopBtn.disabled = false;
            const oneBatchBtn = document.getElementById('one-batch-btn') as HTMLButtonElement | null; if (oneBatchBtn) oneBatchBtn.disabled = false;
            const startBtn2 = document.getElementById('start-btn') as HTMLButtonElement | null; if (startBtn2) startBtn2.disabled = true;
            
            // Ocultar spinner despu√©s de completar
            this.hideStartSpinner();
            try { this.updateControlButtons(); } catch {}
            
          } catch (error) {
            this.log(`‚ùå Error starting session: ${error}`);
            // Ocultar spinner en caso de error
            this.hideStartSpinner();
          }
        }

        async pauseSession() {
          if (!this.currentSession) return;
          
          try {
            await fetch(`${this.apiBase()}/api/sessions/${this.currentSession}/pause`, { method: 'POST' });
            this.log('Session paused');
            this.sessionStatus = 'paused';
            try { this.updateControlButtons(); } catch {}
          } catch (error) {
            this.log(`Error pausing session: ${error}`);
          }
        }

        async stopSession() {
          if (!this.currentSession) return;
          
          try {
            await fetch(`${this.apiBase()}/api/sessions/${this.currentSession}/stop`, { method: 'POST' });
            this.log('Session stopped');
            this.currentSession = null;
            this.sessionStatus = null;
            const startBtn3 = document.getElementById('start-btn') as HTMLButtonElement | null; if (startBtn3) startBtn3.disabled = false;
            const pauseBtn2 = document.getElementById('pause-btn') as HTMLButtonElement | null; if (pauseBtn2) pauseBtn2.disabled = true;
            const stopBtn2 = document.getElementById('stop-btn') as HTMLButtonElement | null; if (stopBtn2) stopBtn2.disabled = true;
            const oneBatchBtn = document.getElementById('one-batch-btn') as HTMLButtonElement | null; if (oneBatchBtn) oneBatchBtn.disabled = true;
            try { this.updateControlButtons(); } catch {}
          } catch (error) {
            this.log(`Error stopping session: ${error}`);
          }
        }

        async sendOneBatch() {
          try {
            const selectedSlaves = Array.from(document.querySelectorAll<HTMLInputElement>('.slave-toggle:checked')).map(cb => cb.value);
            if (!selectedSlaves.length) { this.log('‚ö†Ô∏è Selecciona al menos un slave'); return; }
            if (!this.detectedBotMode || !this.projectConfig) { this.log('‚ö†Ô∏è Carga un proyecto antes de pedir un lote'); return; }
            // Asegurar sesi√≥n/proyecto creados si no exist√≠an
            if (!this.currentSession) {
              let projectConfig = { mode: this.detectedBotMode, config: this.projectConfig || {} };
              const projectResponse = await fetch(`${this.apiBase()}/api/projects`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: `Session ${Date.now()}`, ...projectConfig }) });
              const projectData = await projectResponse.json();
              const sessionResponse = await fetch(`${this.apiBase()}/api/sessions`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ project_id: projectData.project_id, slave_ids: selectedSlaves, strategy: (document.getElementById('gc-chargeStrategy') as HTMLSelectElement | null)?.value || this.guardConfig?.chargeStrategy || 'greedy' }) });
              const sessionData = await sessionResponse.json();
              this.currentSession = sessionData.session_id;
            }
            this.log('üéØ Ejecutando un lote usando el planificador cooperativo');
            const res = await fetch(`${this.apiBase()}/api/sessions/${this.currentSession}/one-batch`, { method: 'POST' });
            const js = await res.json();
            if (res.ok && js.ok) {
              this.log(`‚úÖ Lote planificado: asignados ${js.assigned}, cargas totales ${js.total_remaining}`);
              const rc = document.getElementById('remaining-charges'); if (rc) rc.textContent = String(js.total_remaining ?? '');
            } else {
              this.log(`‚ö†Ô∏è No se pudo planificar lote: ${js.reason || js.detail || 'unknown'}`);
            }
          } catch (e) {
            this.log(`‚ùå Error en 'Un lote': ${e?.message || e}`);
          }
        }

        

          async loadGuardConfig(){
            const st = document.getElementById('guard-config-status');
            try {
              if (st) st.textContent = 'Loading...';
              const res = await fetch(`${this.apiBase()}/api/guard/config`);
              const js = await res.json();
              this.guardConfig = js.config || {};
              this.autoDistribute = !!(this.guardConfig as any)?.autoDistribute;
              if (st) st.textContent = 'Config loaded';
              const st2 = document.getElementById('gc-status'); if (st2) st2.textContent = 'Config loaded';
              this.log('‚öôÔ∏è Guard config loaded');
              // Inicializar sets y reflejar en el formulario inline
              try {
                this._preferredColorIds = new Set(Array.isArray(this.guardConfig?.preferredColorIds) ? this.guardConfig.preferredColorIds : []);
                this._excludedColorIds = new Set(Array.isArray(this.guardConfig?.excludedColorIds) ? this.guardConfig.excludedColorIds : []);
                this.applyGuardConfigToForm();
                this.ensureInlineSectionsVisibility();
                this.renderAllInlineChips();
              } catch {}
            } catch(e: any){
              if (st) st.textContent = 'Error loading config';
              const st2 = document.getElementById('gc-status'); if (st2) st2.textContent = 'Error loading config';
              this.log('‚ùå Error loading guard config: '+ e?.message);
            }
          }

          applyGuardConfigToForm(){
            const cfg = (this.guardConfig as any) || {};
            const map = [
              ['gc-protectionPattern','protectionPattern'],
              ['gc-preferColor','preferColor','checkbox'],
              ['gc-excludeColor','excludeColor','checkbox'],
              ['gc-spendAllPixelsOnStart','spendAllPixelsOnStart','checkbox'],
              ['gc-randomWaitTime','randomWaitTime','checkbox'],
              // removed watchMode & autoDistribute
              ['gc-minChargesToWait','minChargesToWait'],
              ['gc-pixelsPerBatch','pixelsPerBatch'],
              ['gc-chargeStrategy','chargeStrategy'],
              ['gc-recentLockSeconds','recentLockSeconds'],
              ['gc-randomWaitMin','randomWaitMin'],
              ['gc-randomWaitMax','randomWaitMax'],
              ['gc-colorThreshold','colorThreshold']
            ];
            map.forEach(([id,key,type])=>{ 
              const el:any = document.getElementById(id); 
              if(!el) return; 
              if(type==='checkbox') el.checked = !!(cfg as any)[key]; 
              else if((cfg as any)[key]!==undefined) el.value = (cfg as any)[key]; 
            });
            // Mostrar/ocultar tiempos aleatorios seg√∫n toggle
            try {
              const rt = document.getElementById('gc-randomWaitTime') as HTMLInputElement | null;
              const times = document.getElementById('gc-random-times') as HTMLElement | null;
              if (times) times.style.display = (rt && rt.checked) ? '' : 'none';
            } catch {}
          }

          async saveGuardConfig(){
            const payload:any = {};
            const fields = [
              ['gc-protectionPattern','protectionPattern','value'],
              ['gc-preferColor','preferColor','checked'],
              ['gc-excludeColor','excludeColor','checked'],
              ['gc-spendAllPixelsOnStart','spendAllPixelsOnStart','checked'],
              ['gc-randomWaitTime','randomWaitTime','checked'],
              // removed watchMode & autoDistribute
              ['gc-minChargesToWait','minChargesToWait','value','int'],
              ['gc-pixelsPerBatch','pixelsPerBatch','value','int'],
              ['gc-chargeStrategy','chargeStrategy','value'],
              ['gc-recentLockSeconds','recentLockSeconds','value','int'],
              ['gc-randomWaitMin','randomWaitMin','value','float'],
              ['gc-randomWaitMax','randomWaitMax','value','float'],
              ['gc-colorThreshold','colorThreshold','value','int']
            ];
            fields.forEach(([id,key,prop,cast])=>{ const el:any=document.getElementById(id); if(!el) return; let v=el[prop]; if(cast==='int') v=parseInt(v,10); else if(cast==='float') v=parseFloat(v); payload[key]=v; });
            try {
              const res = await fetch(`${this.apiBase()}/api/guard/config`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
              const js = await res.json();
              if(js.ok){ this.guardConfig = js.config; this.autoDistribute = !!this.guardConfig.autoDistribute; this.log('üíæ Guard config saved'); try{ this.recomputeRoundPlan(); }catch{} }
              else { this.log('‚ö†Ô∏è Guard config save failed'); }
            } catch(e){ this.log('‚ùå Error saving guard config: '+ e.message); }
          }

          // legacy modal removed

        // ===== Inline Config Panel wiring =====
        setupConfigPanelListeners(){
          if (this._configWired) return; // evitar duplicados
          const panel = document.getElementById('config-panel');
          if (!panel) return; // componente no presente
          this._configWired = true;

          // Toggles: sincronizar visual y mostrar/ocultar secciones
          const wireToggle = (id:string, sectionId?:string, onChange?:()=>void) => {
            const el = document.getElementById(id) as HTMLInputElement | null;
            if (!el) return;
            // estado visual inicial
            this.updateToggleState(id, el.checked);
            if (sectionId) {
              const sec = document.getElementById(sectionId);
              if (sec) sec.style.display = el.checked ? '' : 'none';
            }
            el.addEventListener('change', () => {
              this.updateToggleState(id, el.checked);
              if (sectionId) {
                const sec = document.getElementById(sectionId);
                if (sec) sec.style.display = el.checked ? '' : 'none';
                if (el.checked) {
                  // Asegurar chips renderizados si se abre la secci√≥n
                  this.renderAllInlineChips();
                }
              }
              if (onChange) onChange();
            });
          };
          wireToggle('gc-preferColor','gc-preferredColors-section');
          wireToggle('gc-excludeColor','gc-excludedColors-section');
          wireToggle('gc-spendAllPixelsOnStart', undefined, () => { try{ this.recomputeRoundPlan(); }catch{} });
          // removed toggles wireToggle for autoDistribute & watchMode
          wireToggle('gc-randomWaitTime', undefined, () => {
            try {
              const rt = document.getElementById('gc-randomWaitTime') as HTMLInputElement | null;
              const times = document.getElementById('gc-random-times') as HTMLElement | null;
              if (times) times.style.display = (rt && rt.checked) ? '' : 'none';
            } catch {}
          });

          // Botones guardar / reset
          const resetBtn = document.getElementById('gc-reset-btn');
          if (resetBtn) resetBtn.addEventListener('click', () => this.resetInlineGuardConfig());

          // Autosave en inputs y selects (change/blur)
          const panelRoot = document.getElementById('config-panel');
          if (panelRoot) {
            panelRoot.querySelectorAll('input, select').forEach((el:any) => {
              el.addEventListener('change', () => this.scheduleConfigAutosave());
              el.addEventListener('blur', () => this.scheduleConfigAutosave());
              if (el.id === 'gc-chargeStrategy') {
                el.addEventListener('change', () => { try { this.recomputeRoundPlan(); } catch {} });
              }
            });
          }

          // Render inicial de chips si ya hay paleta
          try { this.applyGuardConfigToForm(); this.ensureInlineSectionsVisibility(); this.renderAllInlineChips(); } catch {}
        }

        ensureInlineSectionsVisibility(){
          const p = document.getElementById('gc-preferColor') as HTMLInputElement | null;
          const e = document.getElementById('gc-excludeColor') as HTMLInputElement | null;
          const ps = document.getElementById('gc-preferredColors-section'); if (ps) ps.style.display = p && p.checked ? '' : 'none';
          const es = document.getElementById('gc-excludedColors-section'); if (es) es.style.display = e && e.checked ? '' : 'none';
          if (p) this.updateToggleState('gc-preferColor', p.checked);
          if (e) this.updateToggleState('gc-excludeColor', e.checked);
        }

        renderAllInlineChips(){
          try {
            const palette = (this.lastPreviewData && this.lastPreviewData.availableColors) || [];
            if (!Array.isArray(palette) || palette.length === 0) return;
            this.renderInlineColorChips('gc-preferredColors', palette, this._preferredColorIds, 'preferred');
            this.renderInlineColorChips('gc-excludedColors', palette, this._excludedColorIds, 'excluded');
          } catch {}
        }

        renderInlineColorChips(containerId:string, colors:any[], selected:Set<number>, mode:'preferred'|'excluded'){
          try {
            const container = document.getElementById(containerId); if (!container) return;
            container.innerHTML = '';
            const clearBtnId = (mode === 'preferred') ? 'gc-clearPreferred' : 'gc-clearExcluded';
            const clearBtn = document.getElementById(clearBtnId);
            const updateClear = () => { if (clearBtn) (clearBtn as HTMLButtonElement).style.display = selected.size > 0 ? '' : 'none'; };
            // Wire clear button
            if (clearBtn && !(clearBtn as any)._wired) {
              (clearBtn as any)._wired = true;
              clearBtn.addEventListener('click', () => { selected.clear(); this.renderInlineColorChips(containerId, colors, selected, mode); });
            }
            colors.forEach((c:any) => {
              const chip = document.createElement('div');
              chip.className = 'relative';
              chip.style.cssText = `width:28px;height:28px;border-radius:6px;cursor:pointer;border:2px solid ${selected.has(c.id)?(mode==='preferred'?'#10b981':'#ef4444'):'transparent'};background:rgb(${c.r},${c.g},${c.b});`;
              chip.title = `Color ${c.id}: RGB(${c.r},${c.g},${c.b})`;
              const icon = document.createElement('div');
              icon.style.cssText = `position:absolute;top:-3px;right:-3px;width:16px;height:16px;border-radius:50%;display:${selected.has(c.id)?'flex':'none'};align-items:center;justify-content:center;color:#fff;font-size:10px;font-weight:700;border:2px solid #fff;box-shadow:0 2px 4px rgba(0,0,0,.3);background:${mode==='preferred'?'#10b981':'#ef4444'};`;
              icon.textContent = mode === 'preferred' ? '‚úì' : '‚úï';
              chip.appendChild(icon);
              chip.addEventListener('click', () => {
                if (selected.has(c.id)) { selected.delete(c.id); chip.style.borderColor = 'transparent'; icon.style.display = 'none'; }
                else { selected.add(c.id); chip.style.borderColor = (mode==='preferred'?'#10b981':'#ef4444'); icon.style.display = 'flex'; }
                updateClear();
                this.scheduleConfigAutosave();
              });
              container.appendChild(chip);
            });
            updateClear();
          } catch {}
        }

        scheduleConfigAutosave(delay:number=350){
          try{
            if (this._saveTimer) clearTimeout(this._saveTimer);
            this._saveTimer = setTimeout(() => {
              this._saveTimer = null;
              this.saveInlineGuardConfig();
            }, Math.max(0, delay));
          }catch{}
        }

        updateConfigPanelEnabledState(){
          const panel = document.getElementById('config-panel'); if (!panel) return;
          const hint = document.getElementById('config-disabled-hint');
          const enabled = this.slaves.size > 0;
          const selectors = panel.querySelectorAll('input, select, button');
          selectors.forEach((el:any) => { if (el.id !== 'gc-status') el.disabled = !enabled; });
          if (hint) hint.style.display = enabled ? 'none' : '';
          panel.style.opacity = enabled ? '1' : '0.6';
        }

        saveInlineGuardConfig(){
          const payload:any = {};
          const fields = [
            ['gc-protectionPattern','protectionPattern','value'],
            ['gc-preferColor','preferColor','checked'],
            ['gc-excludeColor','excludeColor','checked'],
            ['gc-spendAllPixelsOnStart','spendAllPixelsOnStart','checked'],
            ['gc-randomWaitTime','randomWaitTime','checked'],
            // removed watchMode & autoDistribute
            ['gc-minChargesToWait','minChargesToWait','value','int'],
            ['gc-pixelsPerBatch','pixelsPerBatch','value','int'],
            ['gc-chargeStrategy','chargeStrategy','value'],
            ['gc-recentLockSeconds','recentLockSeconds','value','int'],
            ['gc-randomWaitMin','randomWaitMin','value','float'],
            ['gc-randomWaitMax','randomWaitMax','value','float'],
            ['gc-colorThreshold','colorThreshold','value','int']
          ];
          fields.forEach(([id,key,prop,cast])=>{ const el:any=document.getElementById(id as string); if(!el) return; let v=el[prop as string]; if(cast==='int') v=parseInt(v,10); else if(cast==='float') v=parseFloat(v); (payload as any)[key as string]=v; });
          // A√±adir arrays de colores
          payload.preferredColorIds = Array.from(this._preferredColorIds);
          payload.excludedColorIds = Array.from(this._excludedColorIds);
          const st = document.getElementById('gc-status'); if (st) st.textContent = 'Saving...';
          fetch(`${this.apiBase()}/api/guard/config`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)})
            .then(r=>r.json())
            .then(js=>{
              if (js.ok) {
                this.guardConfig = js.config || payload;
                this.autoDistribute = !!this.guardConfig.autoDistribute;
                if (st) st.textContent = 'Saved';
                try { this.recomputeRoundPlan(); } catch {}
              } else { if (st) st.textContent = 'Save failed'; }
            })
            .catch(e=>{ if (st) st.textContent = 'Error saving'; this.log('‚ùå Error saving config: '+(e?.message||e)); });
        }

        async resetInlineGuardConfig(){
          if (!confirm('Reset to defaults?')) return;
          const defaults={protectionPattern:'random',preferColor:false,excludeColor:false,minChargesToWait:20,pixelsPerBatch:10,chargeStrategy:'greedy',spendAllPixelsOnStart:false,randomWaitTime:false,randomWaitMin:5,randomWaitMax:15,colorThreshold:10,watchMode:true,autoDistribute:false,preferredColorIds:[],excludedColorIds:[]};
          const st = document.getElementById('gc-status'); if (st) st.textContent = 'Resetting...';
          try{
            const r = await fetch(`${this.apiBase()}/api/guard/config`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(defaults)});
            const j = await r.json();
            if (j.ok){
              this.guardConfig = j.config;
              this._preferredColorIds = new Set();
              this._excludedColorIds = new Set();
              this.applyGuardConfigToForm();
              this.ensureInlineSectionsVisibility();
              this.renderAllInlineChips();
              if (st) st.textContent = 'Reset done';
              this.log('üîÑ Config reseteada');
            } else { if (st) st.textContent = 'Reset failed'; }
          } catch(e:any){ if (st) st.textContent = 'Error resetting'; this.log('‚ùå Reset error: '+(e?.message||e)); }
        }
        log(message: string) {
          const container = document.getElementById('logs-container');
          if(!container) return;
          const timestamp = new Date().toLocaleTimeString();
          const logEntry = document.createElement('div');
          logEntry.className = 'text-xs mb-1';
          logEntry.innerHTML = `<span class="text-muted-foreground">[${timestamp}]</span> ${message}`;
          container.appendChild(logEntry);
          container.scrollTop = container.scrollHeight;
          while (container.children.length > 200) { container.removeChild(container.firstChild); }
        }

        // ===== Compresi√≥n / Descompresi√≥n UI =====
        _maybeUnwrapCompressed(obj){
          try {
            if (!obj || typeof obj !== 'object') return obj;
            if (obj.type !== '__compressed__') return obj;
            if (!obj.encoding || obj.encoding !== 'gzip+base64') return obj;
            // Lazy load pako solo cuando se necesita (parcel/astro soporta dynamic import)
            const b64 = obj.payload;
            if (typeof b64 !== 'string') return obj; // corrupto
            const binStr = atob(b64);
            const len = binStr.length;
            const bytes = new Uint8Array(len);
            for (let i=0;i<len;i++) bytes[i] = binStr.charCodeAt(i);
            // Utilizamos pako ungzip
            // Nota: import din√°mico; si falla, retornamos wrapper original para no romper flujo
            return this._gunzip(bytes).then(js => {
              // Si el wrapper tra√≠a originalType, y el contenido es objeto sin type, reinyectar
              if (obj.originalType && js && typeof js === 'object' && !js.type) {
                js.type = obj.originalType;
              }
              return js;
            }).catch(err => {
              this.log('‚ö†Ô∏è Decompression failed: '+ (err?.message || err));
              return obj; // fallback
            });
          } catch(e){
            this.log('‚ö†Ô∏è _maybeUnwrapCompressed error: '+ (e?.message || e));
            return obj;
          }
        }

        async _gunzip(bytes){
          const { ungzip } = await import('pako');
            const decompressed = ungzip(bytes, { to: 'string' });
            const parsed = JSON.parse(decompressed);
            // Para mantener compat, si viene single object lo devolvemos; si es wrapper with originalType, homogenizar
            if (parsed && typeof parsed === 'object' && parsed.type && parsed.type !== '__compressed__') return parsed;
            return parsed;
        }

        // Dedupe helper with TTL
        logOnce(key: string, message: string, ttl: number = 4000) {
          try {
            const now = Date.now();
            // cleanup
            for (const [k, t] of this.recentLogKeys.entries()) {
              if (now - t > ttl) this.recentLogKeys.delete(k);
            }
            if (this.recentLogKeys.has(key)) return; // skip duplicate within TTL
            this.recentLogKeys.set(key, now);
            this.log(message);
          } catch { this.log(message); }
        }
        
        getFavoriteSlaveId(): string | null {
          try {
            for (const s of this.slaves.values()) { if (s && s.is_favorite) return s.id; }
          } catch {}
          return null;
        }
        
        apiBase() { 
          return this.getServerUrl(); 
        }

        getServerUrl() {
          // Usar variable de entorno si est√° configurada, sino usar servidor local por defecto
          const configuredUrl = import.meta.env.PUBLIC_SERVER_URL;
          console.log(`üîß Raw SERVER_URL config: "${configuredUrl}"`);
          
          if (configuredUrl && configuredUrl.trim()) {
            const normalized = this.normalizeServerUrl(configuredUrl.trim());
            console.log(`üîß Normalized SERVER_URL: "${normalized}"`);
            return normalized;
          }
          
          const fallback = `${window.location.protocol}//${window.location.hostname}:8008`;
          console.log(`üîß Using fallback SERVER_URL: "${fallback}"`);
          return fallback;
        }

        normalizeServerUrl(url) {
          // Si no tiene protocolo, detectar autom√°ticamente
          if (!url.startsWith('http://') && !url.startsWith('https://')) {
            // Detectar protocolo basado en el actual o usar https por defecto para dominios remotos
            const protocol = window.location.protocol === 'https:' ? 'https://' : 'http://';
            url = protocol + url;
          }
          
          // Si no tiene puerto y es un dominio remoto detr√°s de nginx, asumimos puerto est√°ndar
          if (!url.match(/:\d+$/) && !url.includes('localhost') && !url.includes('127.0.0.1')) {
            // Para dominios remotos sin puerto, nginx maneja la redirecci√≥n autom√°ticamente
            return url;
          }
          
          // Para localhost sin puerto espec√≠fico, agregar :8008
          if ((url.includes('localhost') || url.includes('127.0.0.1')) && !url.match(/:\d+$/)) {
            url = url + ':8008';
          }
          
          return url;
        }

        getWebSocketUrl() {
          const serverUrl = this.getServerUrl();
          const protocol = serverUrl.startsWith('https://') ? 'wss://' : 'ws://';
          const cleanUrl = serverUrl.replace(/^https?:\/\//, '');
          const wsUrl = `${protocol}${cleanUrl}/ws/ui`;
          console.log(`üîß WebSocket URL: "${wsUrl}"`);
          return wsUrl;
        }

        // ======= NUEVOS HELPERS UI DE CUOTAS Y PROGRESO =======
        updateSlaveCardQuota(slaveId:string, value:number, pct:number){
          try{
            const el = document.getElementById(`slave-${slaveId}-quota`);
            const bar = document.getElementById(`slave-${slaveId}-quota-bar`);
            if (el) el.textContent = String(value || 0);
            if (bar) (bar as HTMLElement).style.width = `${Math.max(0, Math.min(100, Math.round((pct || 0) * 100)))}%`;
          }catch{}
        }

        recomputeRoundPlan(){
          try {
            const selectedIds = Array.from(document.querySelectorAll<HTMLInputElement>('.slave-toggle:checked')).map(cb => cb.value);
            if (!selectedIds.length) {
              this.slaves.forEach((_, sid) => this.updateSlaveCardQuota(sid, 0, 0));
              this.currentRoundPlan = {};
              return;
            }
            const charges:any = {}; let total = 0;
            selectedIds.forEach(sid => { const rc = Number(this.slaves.get(sid)?.telemetry?.remaining_charges || 0) || 0; charges[sid] = rc; total += rc; });
            this.log(`üí≥ Charges: total=${total}, details=${JSON.stringify(charges)}`);
            const pixelsPerBatch = Number((this.guardConfig?.pixelsPerBatch) ?? 10) || 10;
            const spendAll = !!this.guardConfig?.spendAllPixelsOnStart;
            const strategySelect = (document.getElementById('gc-chargeStrategy') as HTMLSelectElement | null);
            const strategy = (strategySelect?.value || this.guardConfig?.chargeStrategy || 'greedy').toLowerCase();
            let roundTotal = spendAll ? total : Math.min(total, pixelsPerBatch);
            if (roundTotal <= 0) {
              selectedIds.forEach(sid => this.updateSlaveCardQuota(sid, 0, 0));
              this.currentRoundPlan = {};
              return;
            }
            // --- compute_distribution (mirror) ---
            const valid: Record<string, number> = {}; selectedIds.forEach(sid => { if (charges[sid] > 0) valid[sid] = Number(charges[sid]) || 0; });
            const capTotal: number = Object.values(valid).reduce((a, b) => a + (Number(b) || 0), 0);
            const target: number = Math.min(Number(roundTotal)||0, Number(capTotal)||0);
            let plan:any = {}; selectedIds.forEach(sid => plan[sid] = 0);
            if (target > 0 && capTotal > 0) {
              if (strategy === 'round_robin') {
                const order = Object.keys(valid);
                let idx=0, assigned=0;
                while (assigned < target && order.length){
                  const sid = order[idx % order.length];
                  if (plan[sid] < valid[sid]) { plan[sid]++; assigned++; }
                  idx++;
                  if (assigned < target && order.every(s => plan[s] >= valid[s])) break;
                }
              } else if (strategy === 'balanced') {
                const totalCh = capTotal || 1; let assigned=0; const fractional:any[]=[];
                Object.entries(valid).forEach(([sid, ch]: any)=>{
                  const ideal = (ch/totalCh)*target; const base = Math.min(Math.floor(ideal), ch);
                  plan[sid]=base; assigned+=base; fractional.push([sid, ideal-base]);
                });
                if (assigned < target){
                  fractional.sort((a,b)=>b[1]-a[1]);
                  for (const [sid,_r] of fractional){
                    if (assigned>=target) break;
                    if (plan[sid] < valid[sid]) { plan[sid]++; assigned++; }
                  }
                }
                Object.keys(plan).forEach(sid=>{ if (plan[sid] > (valid[sid]||0)) plan[sid]=valid[sid]; });
              } else { // greedy
                const ordered = Object.entries(valid).sort((a,b)=> (Number(b[1])||0) - (Number(a[1])||0));
                let remaining = target;
                for (const [sid, ch] of ordered){
                  if (remaining<=0) break; const take = Math.min(Number(ch)||0, remaining); plan[sid]=take; remaining-=take;
                }
              }
              // Ajuste residual
              const targetNum = Number(target)||0;
              const planVals: number[] = Object.values(plan).map(v=>Number(v)||0);
              let diff = targetNum - planVals.reduce((a:number,b:number)=>a+b,0);
              if (diff>0){
                const expandable = Object.keys(valid).filter(sid=>plan[sid] < valid[sid]);
                let k=0;
                while (diff>0 && expandable.length){
                  const sid = expandable[k % expandable.length];
                  if (plan[sid] < valid[sid]) { plan[sid]++; diff--; }
                  k++;
                  if (expandable.every(s=>plan[s] >= valid[s])) break;
                }
              }
            }
            // --- end compute_distribution ---
            const changes = (this.lastPreviewData && Array.isArray(this.lastPreviewData.changes)) ? this.lastPreviewData.changes : [];
            this.log(`üîç Raw changes: ${changes.length}, types: ${changes.map(c=>c?.type).filter(Boolean).join(',')}`);
            const excluded = (this.guardConfig?.excludeColor && Array.isArray(this.guardConfig?.excludedColorIds)) ? new Set(this.guardConfig.excludedColorIds) : new Set();
            // Tratar incorrect igual que missing; filtrar bloqueados por TTL
            const eligible = changes.filter(c => {
              const t = c?.type;
              if (!(t === 'missing' || t === 'absent' || t === 'incorrect')) return false;
              const col = (c?.expectedColor ?? c?.color ?? -1);
              if (excluded.has(col)) return false;
              const k = (typeof c?.x !== 'undefined' && typeof c?.y !== 'undefined') ? `${c.x},${c.y}` : '';
              if (k && this._recentRepairs.has(k) && (this._recentRepairs.get(k) || 0) > 0) return false;
              return true;
            });
            this.log(`‚úÖ Eligible changes: ${eligible.length} (excluded colors: ${excluded.size}, TTL blocked: ${changes.length - eligible.length - [...excluded].length})`);
            const maxAssignable = eligible.length;
            const planSum = Object.values(plan).reduce((a:any,b:any)=>a+b,0);
            let finalPlan = { ...plan } as any;
            if (maxAssignable < planSum) {
              const rr: string[] = [];
              Object.entries(plan).forEach(([sid, count]: any) => { for (let k=0;k<count;k++) rr.push(sid as string); });
              const take = rr.slice(0, maxAssignable);
              finalPlan = {}; selectedIds.forEach(sid => finalPlan[sid] = 0);
              take.forEach(sid => finalPlan[sid] += 1);
            }
            selectedIds.forEach(sid => {
              const val = finalPlan[sid] || 0; const cap = Math.max(1, charges[sid] || 0);
              this.updateSlaveCardQuota(sid, val, val / cap);
            });
            this.slaves.forEach((_, sid) => { if (!selectedIds.includes(sid)) this.updateSlaveCardQuota(sid, 0, 0); });
            this.currentRoundPlan = finalPlan;
            // Log plan
            try {
              const totalPlan = Object.values(finalPlan).reduce((a: number, b: any)=> a + (Number(b)||0), 0);
              const summary = Object.entries(finalPlan).map(([k,v])=>`${k}:${v}`).join(' ');
              this.log(`üî¢ Plan(strategy=${strategy}) total=${totalPlan} ${summary}`);
            } catch {}
          } catch(e){ this.log('‚ö†Ô∏è Recompute plan error: '+ (e?.message || e)); }
        }

        // ====== Bloqueo temporal de coords reparadas (TTL por previews favoritos) ======
        markRecentRepairs(coords: Array<{x:number,y:number}>){
          try{
            coords.forEach(p=>{ if (typeof p?.x !== 'undefined' && typeof p?.y !== 'undefined') this._recentRepairs.set(`${p.x},${p.y}`, this._recentTTL); });
          }catch{}
        }
        ageRecentRepairs(){
          try{
            const del: string[] = [];
            this._recentRepairs.forEach((ttl, k) => {
              const nv = (ttl||0) - 1;
              if (nv <= 0) del.push(k); else this._recentRepairs.set(k, nv);
            });
            del.forEach(k => this._recentRepairs.delete(k));
          }catch{}
        }

        // ====== Resaltado de tarjeta por slave (verde √©xito / rojo error) ======
        highlightSlaveCard(slaveId: string, success: boolean){
          try {
            const el = document.getElementById(`slave-${slaveId}`);
            if (!el) return;
            const add = success ? 'flash-green' : 'flash-red';
            const remove = success ? 'flash-red' : 'flash-green';
            // Limpiar animaci√≥n opuesta
            el.classList.remove(remove);
            // Reiniciar si ya hay un timer
            if (this._flashTimers.has(slaveId)) {
              clearTimeout(this._flashTimers.get(slaveId));
              this._flashTimers.delete(slaveId);
            }
            // Forzar reflow para reiniciar animaci√≥n si misma clase
            void (el as HTMLElement).offsetWidth;
            el.classList.add(add);
            const timer = setTimeout(() => {
              try { el.classList.remove(add); } catch {}
              this._flashTimers.delete(slaveId);
            }, 1250);
            this._flashTimers.set(slaveId, timer);
          } catch {}
        }

        updateOverallProgressBar(accuracyPercentNumber:number){
          try{
            const pct = Math.max(0, Math.min(100, Number(accuracyPercentNumber) || 0));
            const bar = document.getElementById('overall-progress-bar');
            const lbl = document.getElementById('overall-progress-label');
            if (bar) (bar as HTMLElement).style.width = `${pct}%`;
            if (lbl) lbl.textContent = `${pct.toFixed(1)}%`;
          }catch{}
        }

        // ====== Funciones del spinner para el bot√≥n Start ======
        showStartSpinner(){
          try {
            const startBtn = document.getElementById('start-btn') as HTMLButtonElement | null;
            const startBtnText = document.getElementById('start-btn-text') as HTMLElement | null;
            const startBtnSpinner = document.getElementById('start-btn-spinner') as HTMLElement | null;
            
            if (startBtn && startBtnText && startBtnSpinner) {
              // Deshabilitar bot√≥n
              startBtn.disabled = true;
              
              // Ocultar texto con transici√≥n suave
              startBtnText.style.opacity = '0';
              
              // Mostrar spinner con transici√≥n suave
              setTimeout(() => {
                startBtnSpinner.style.opacity = '1';
              }, 150); // Peque√±o delay para que la transici√≥n sea m√°s fluida
            }
          } catch(e) {
            this.log(`‚ö†Ô∏è Error showing spinner: ${e?.message || e}`);
          }
        }

        hideStartSpinner(){
          try {
            const startBtn = document.getElementById('start-btn') as HTMLButtonElement | null;
            const startBtnText = document.getElementById('start-btn-text') as HTMLElement | null;
            const startBtnSpinner = document.getElementById('start-btn-spinner') as HTMLElement | null;
            
            if (startBtn && startBtnText && startBtnSpinner) {
              // Ocultar spinner
              startBtnSpinner.style.opacity = '0';
              
              // Mostrar texto despu√©s de ocultar spinner
              setTimeout(() => {
                startBtnText.style.opacity = '1';
                // El bot√≥n se habilita/deshabilita seg√∫n la l√≥gica de updateControlButtons()
              }, 150);
            }
          } catch(e) {
            this.log(`‚ö†Ô∏è Error hiding spinner: ${e?.message || e}`);
          }
        }

        requestPreviewRefreshThrottle(){
          try{
            const now = Date.now();
            if (now < (this._previewRefreshCooldownUntil || 0)) return;
            this._previewRefreshCooldownUntil = now + 4000;
            fetch(`${this.apiBase()}/api/guard/check`, { method: 'POST' }).catch(()=>{});
          }catch{}
        }
      }

      // Initialize dashboard when page loads
      document.addEventListener('DOMContentLoaded', () => {
        new WPlaceDashboard();
      });
    </script>
  </body>
</html>